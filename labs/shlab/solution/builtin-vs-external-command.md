## 内置命令 vs 外部命令

通过对 `argv` 参数的一系列格式化操作，我们可以得到一个相对规范的参数列表。

这个时候我们就可以对输入的命令进行一个基本的拆分和判断：

1. `argv[0]` 根本没有值，用户可能没有输入任何有效内容，只是打了个回车，我们也不需要做任何处理；
2. `argv[0]` 要么是内置命令，要么是某个指定路径的二进制文件；
    - 程序需要遍历内置命令列表，确定当前命令是否是内置命令，如果是则直接执行；
    - 否则就会认为该命令是二进制文件的路径，需要新开一个子进程去处理；
    - 注意，即使是存在系统环境变量里的命令，比如 `ls`，也是需要新开一个子进程处理的，其不属于内置命令；

外部命令需要新开子进程处理的一个原因是进程隔离，因为 shell 无法确定外部命令的功能，需要用子进程来保护 shell 本身的内存空间不受破坏。

内置命令实际上是 shell 程序内部的某个方法，在识别到之后直接调用该方法即可，比如说实验中要求实现的 `quit` 和 `jobs` 命令，实际上只是调用某些方法，直接操作 shell 进程而已。

```c
int builtin_cmd(char **argv) {
    if (!strcmp(argv[0], "quit")) {
        exit(0);
    }
    return 0; /* not a builtin command */
}
```

在我们的 tsh 中，因为内置命令很少，我们只需要用 `strcmp` 来做简单的字符串匹配即可。

注意 `strcmp` 会在相等的时候返回 0，大于或者小于的时候返回 1 或者 -1，所以这里 `!` 实际上是等于 0 的判断，即是否相等。
