## 数字的表示方式

### 数字在计算机中的表示

计算机硬件本身只知道 0 或 1，而没有数字的概念，所以需要人为定义数字的表示方式。

以 4 位二进制数为例，可以表示 16 个不同的数字，从 0 到 15。

但是如果将最高位表示为符号位，则有：

- 最高位为 0，表示正数，最小值为 0000，即 0，最大值为 0111，即 7
- 最高位为 1，表示负数，最小值为 1000，即 -8，最大值为 1111，即 -1

由此可见，除去符号位以外，剩下的三位是完全一样的。

这里的计算方式是：每一位代表的大小都是 2^(w-1)，然后与对应的值相乘后相加，只不过注意符号位的正负。

编码表示为： 

$$
x_{w-1} * 2^{w-1} + x_{w-2} * 2^{w-2} + ... + x_0 * 2^0
$$

其中，$x_{w-1}$ 是符号位，$x_{w-2}$ 到 $x_0$ 是数值位。

举例来说，

0111 = 0*(2^3) + 1*(2^2) + 1*(2^1) + 1*(2^0) = 0 + 4 + 2 + 1 = 7

1111 = -1*(2^3) + 1*(2^2) + 1*(2^1) + 1*(2^0) = -8 + 4 + 2 + 1 = -1

### 有符号数的编码表示

如前所述，计算机本身没有负数的概念，都是人赋予的定义。

同样对于 1111，对于无符号数，其值为 15，而对于有符号数，其值为 -1。

如果给定一个负数，如何知道其对应的二进制表示？这里就需要使用补码表示法，又叫 two's complement。

实现补码的思路是，对于一个数字 $x$，可以找到其对应的负数 $-x$，使得 $x + (-x) = 0$。

以 $0101$ 为例：

1. 先找到该数字相较于 1111 的补码，使得 $0101 + x = 1111$，可得 $x = 1111 - 0101 = 1010$。

2. 对 $1111$ 再加上 1，最终的结果会溢出，得到 $10000$。

3. 溢出的最高位会被丢弃，所以 $10000$ 的值为 $0000$，即 $0$。

4. 所以 $1010 + 1 = 1011$ 就是 $0101$ 的补码。

总的来说就是，对于一个数字 $x$，将 $x$ 的每一位取反，然后加 1，得到的结果就是 $x$ 的补码，即 $-x$ 的二进制表示。

这里需要再强调一下，计算机本身没有负数的概念，负数的二进制表示遵循的是与原码相加等于 0 的规则，而无法真的表示一个负值。

比如，对于 0101 是 5，其补码是 1011，即 -5。这里二进制 1011 可以表示为 -5，也可以表示为 11，完全取决于你如何看待它。

除了上面的逐位相加，还可以利用上面的反码 + 1 的规则，来求出补码对应的十进制值。

以 1011 为例：

1. 确定符号位为 1，表示负数。

2. 将符号位去掉，得到 011。

3. 将 011 的每一位取反，得到 100。

4. 将 100 加 1，得到 101。

5. 所以 101 就是 1011 的补码对应的十进制值，即 -5。

#### 补码的数学定义

我们对一个数求补码的核心思路是基于溢出后最高位被丢弃的特性，而那个最高位就是 $2^w$，即 $2$ 的 $w$ 次方。

因为对于一个 w 位的二进制数，由于 0 占了一个位置，所以最大值是 $2^w - 1$，额外 +1 溢出后的值就是 $2^w$。

在这种情况下，我们就能知道，一个数字的负数补码表示，实际上就是 $2^w - x$。因为我们让 $x$ + $y$ = $2^w$，所以 $y$ 就是 $2^w - x$。

所以，对于一个数字 $x$，其补码 $-x$ 的数学定义为：

$$
-x = 2^w - x
$$

其中，$x$ 是给定的负数，$w$ 是二进制数的位数。

举例来说，对于 4 位数字 7(0111) 来说，套用上面的公式就可以得到：

$$
-7 = 2^4 - 7 = 16 - 7 = 9
$$

所以，7（0111）的补码就是 9（1001）。

0111 的补码是 1001，正好是 0111 取反后得到 1000，然后 +1 的结果。

注意这个公式不是补码的数学理论基础，而是补码的数学解释。

也就是说，这个公式是为了解释补码而定义出来的，只在补码的表示中才成立并且有价值。

### 数字表示的特性

基于上述内容，我们也可以解释几个数字表示的特性：

1. 有符号数的正数和负数可表示范围是不对称的，$|TMin| = |TMax| + 1$。也就是说，$TMin$ 没有与之相对应的正数。
2. 最大的无符号值总是比有符号数的最大值的两倍再大 1，即 $UMax = 2TMax + 1$。

举例来说，对于一个 4 位的数：

- 有符号数的最小值为 -8，最大值为 7，$8 = 7 + 1$
- 无符号数的最大值为 15，$15 = 2*7 + 1$

这些特性存在是都是因为有符号数的不对称性，主要原因是 0000 和 1111 这两个二进制的表示。

0000 的符号位为 0，但是它没有表示正数而是表示了 0，但是 1111 却明确表示了 -1，所以导致正数表示永远比负数少 1 个。

### 有符号数与无符号数之间的转换

再强调一次，机器本身对正负没有概念，机器存储的只是二进制数字，一切都取决于程序怎么解释对应的数字而已。

所以当在有符号数和无符号数之间进行转换的时候，底层的 bit pattern 是不会发生任何变化的，只是程序解释发生了变化。

举例来说，1111 在无符号下表示 15，在有符号下表示 -1。

所以在某些强制类型转换的场景下，发生改变的只有程序运行的上下文，在底层的存储层面是没有任何变化的。

#### C 语言中的有符号数和无符号数

在 C 语言中，如果把有符号数和无符号数放在一起进行比较，程序会在运行时进行隐式类型转换，将有符号数转换为无符号数后再比较，最终导致结果可能不符合预期。

举例来说：

- `-1 < 0U` == false

    - -1 所有位都是 1，转换为无符号数后是 UMax

- `2147483647 > (int)2147483648U` == true

    - 2147483648U 作为无符号数比 int 可以表示的最大值要大，强制转换为 int 后会溢出，然后变成 TMin，即 -2147483648

根据这里的溢出问题扩展一下，C 语言中对于 `INT_MIN` 的宏定义如下：

```c
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```

在 C 和 C++ 中，-2147483648 并不是一个单独的整数字面量，而是 -(2147483648)，其中 2147483648 无法被 int 类型承载，会被转换为 unsigned int，这时候对一个无符号整型取负数，属于未定义行为。

### 扩展和截断

在不同的数据类型之间进行类型转换的时候，因为不同类型能表示的数字范围不同，所以需要在转换后对目标数字的 bit pattern 进行相应的适配操作。

- 低位转高位

    - 无符号在高位补 0，有符号在高位补符号位即可
    - 补符号位的时候，因为二进制的表示是 $x_{w-1} * 2^{w-1} + x_{w-2} * 2^{w-2} + ... + x_0 * 2^0$，高位都是 2 的幂次，所以补完符号位之后，实际上总值的大小不会发生变化
    - 比如，1010 = -4 + 1 = -3
    - 扩展一位后得到，11010 = -8 + 4 + 1 = -3

- 高位转低位
    
    - 按当前可表示的最大位数直接截断，之后按截断后的二进制表示重新计算大小

### Ones' complement vs Two's complement

这两种方式都是用来在计算机中表示负数的方式。

1 的补码是比较早期的方法，这个方法中将 $2^w - 1$，即 1111，定义为 -0，所以求负数表示的重点就是找到一个数距离 1111 ... 111 的补集。

它表示的是 $x$ 距离所有位全为 1 的补，按位取反就可以得到这个补码，所以有时候也管这个叫反码。

而且因为是对所有位全为 1 的补，所以英文的命名是 ones's complement, 有多个 one。

但是这种方式表示负数有一个弊端，就是会有正 0 和负 0，即 0000 和 1111 都表达 0，这给后面的运算带来了很大的麻烦。

2 的补码是在 1 的补码基础上，对 1111 再加 1，利用溢出后截断的特性实现的负数表达。

它表示的是 $x$ 距离 $2^w$ 的补集，即求出 $x$ 加上哪个数可以得到 $2^w$，让我们可以利用溢出的特性得到 0。

所以 2 的补码的英文命名是 Two's complement，这里的 two 实际上指的是 $2^w$。

这个方式可以唯一表达一个 0，并且之后的整数运算也完全不需要区分正负数，是现代计算机表达负数的标准实现。