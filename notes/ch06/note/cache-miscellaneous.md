## Miscellaneous

### 缓存写回

如果 CPU 需要对一个数据进行更新，那这个数据在缓存中有可能命中也有可能不命中。

#### Write Hit

如果缓存命中，CPU 在更新该数据时，如何将数据写回下级缓存是一个很麻烦的问题。

这里主要有两种方式：write-through 和 write-back。

- write-through 

Write-through 就是直接将数据一级级向下写回，更新每一级缓存和内存中的数据。

但是很明显这种方式带来的是效率问题，缓存通道变成了双向的，极有可能造成拥堵，即 bus traffic。

- write-back

Write-back 是只更新缓存里的值，尽可能晚地更新回内存，只有当该缓存需要被替换的时候，将其 evict 之前才会写回内存中。

这样提高了利用效率，避免了多余的开销，但是复杂度上升，需要额外维护一个 dirty 字段来标记某个缓存行是否被修改过。

#### Write Miss

如果需要更新的数据缓存未命中，也有两种方式：no-write-allocate 和 write-allocate。

相对应的就是直接向下级缓存去找那个值，然后一层层向下更新回内存，即 no-write-allocate，和 write-through 类似。

或者就是先把那个值加载到缓存里，然后更新缓存里的值，等待缓存被替换时再写回内存，即 write-allocate，和 write-back 类似。

一般来说，更建议使用 write-back 和 write-allocate 的策略，最大化地利用局部性原理，发挥缓存的作用。

### 真实计算机的缓存

在真实的 CPU 设计中，各级缓存的情况都不相同，通常会有多个类型的缓存，各司其职。

比如有上层缓存有单独的 `d-cache` 用来处理数据，`i-cache` 用来处理指令，`unified cache` 用来处理数据和指令。

这也是出于成本和效率的考虑：

- `i-cache` 是只读的，所以实现起来会更简单；
- 数据和指令分开缓存，可以让 CPU 同时缓存多条数据和指令，提高效率；
- 数据和指令分开，可以避免二者冲突带来的问题。

以 Intel 为例，其 CPU 架构如下图所示：

[intel-cache-hierarchy](./intel-cache.png)

### 缓存性能评价维度

- Miss rate，即缓存未命中率，用 misses / references 表示；
- Hit rate，缓存命中率，1 - miss rate 得到；
- Hit time，从 CPU 开始取值开始到取到值的时间，L1 缓存这个时间大概是几个时钟周期；
- Miss penalty，一旦未命中，从下级缓存中取值导致的额外时间开销，如果 L1 miss 的话，从 L2 取值需要 10 个周期，从 L3 取值需要 50 个周期，从内存取值需要 200 个周期。

### 影响缓存的因素

由于缓存的关联因素过多，任何一个因素的改变都会对缓存结果造成影响，所以缓存的设计更多的是性能、成本、复杂度等各方面的权衡。

- 缓存大小
    - 缓存越大，命中率越高，但是查找速度会随着下降，这也解释了缓存结构的设计
- 缓存块大小
    - 缓存块越大，对于空间局部性好的程序可以提高命中率，因为一个块容纳的数据更多，缓存命中率会更高
    - 但是缓存块变大意味着缓存行变少，缓存替换的频率会变高，所以对于时间局部更好的程序来说，缓存命中率会变低
    - 更大的缓存块会导致 miss penalty 变高，因为检索更大的缓存块需要更多的时间
    - Intel i7 缓存块大小为 64 字节
- 缓存组
    - 缓存组的多少取决于缓存行的多少，所以这里实际上是在讨论缓存行的多少
    - 同一个缓存组内，缓存行越多，命中率越高，因为可以容纳更多冲突情况
    - 但是多行缓存的造价成本很高，而且速度也会变慢，因为遍历成本变高
    - 最终这里的 trade-off 取决于 miss penalty，对性能要求越高的位置组数越少，因为未命中成本太高
    - Intel i7 L1 和 L2 每组 8 个缓存行，L3 是每组 16 行
- 写回策略
    - write-through vs write-back
    - 靠近 CPU 的部分可以利用一个 write-buffer 来直接更新内存
    - 对于远离 CPU 的部分来说，write-back 可以带来更少的数据传输，从而节省出来 I/O 带宽给更重要的工作
- 缓存替换策略
    - LRU 或 LFU 等不同的替换策略也会影响到缓存的命中情况

### set bits 为什么取中间位不取高位

- 高位区分大区域
如果 set bits 选择了高位，它将直接影响到整个内存地址空间，这可能会导致很多冲突和缓存未命中的情况，特别是在内存地址较为稀疏的情况下。而使用中间位，可以更细粒度地划分内存区域，提高缓存的命中率。

- 均匀分布的映射
通过选择中间位，set bits 能够确保内存地址更均匀地映射到缓存组中，减少缓存行之间的冲突。例如，连续的内存地址可能会映射到不同的缓存组中，从而避免缓存行的频繁覆盖和缓存不命中。

- 简化设计
在硬件设计上，采用 中间位 作为 set bits 使得缓存映射更加高效且简化了硬件实现。若将 set bits 选择高位，它会使得硬件需要处理更多复杂的地址映射，增加了设计的难度。

[](./why-set-indexes-in-the-middle.png)
