## Process Control

Unix 提供了一系列系统方法用来主动管理进程。

### 获取进程 ID

- getpid: get process id
- getppid: get parent process id

### 创建和销毁进程

从开发者的角度来看，进程只有三个状态：

1. Running: 要么正在执行，要么等待被执行；
2. Stopped: 被 SIGSTOP 主动停止，必须等收到 SIGCONT 才能继续执行；
3. Terminated: 终止状态，要么是收到了 signal 停止，要么是方法执行结束，要么是调用了 exit 停止；

调用 fork 方法可以主动创建一个子进程，子进程会拷贝父进程的整个地址空间（代码、数据、堆、栈）

之后程序继续执行的时候，就完全独立了，彼此不会有影响。

fork 方法有以下几个特点：

1. 调用一次，执行两次：父进程返回新进程 id，子进程上返回 0；
2. 父子进程并行执行，无法保证谁先谁后；
3. 完全相同的地址空间，但是彼此独立，互不影响（虚拟内存的功劳）；
4. 父进程会共享已经打开的文件描述符，子进程也可以读写访问同一个文件，但数据可能会错乱，除非加锁；

fork 动作会创建一张进程图，而且是一个有向无环图：

1. 由父进程作为起点，有方向地创建子进程；
2. 但由于进程的调度不可预测，所以无法保证执行顺序。

### 子进程的回收

Terminated 之后的进程不会被系统自动回收，而是以僵尸进程的形式继续停留在系统中消耗资源；除非创建该进程的父进程主动对其进行回收。
如果父进程自己死了，它创建的所有子进程都会变成孤儿进程，被 init 进程接管。

父进程可以调用 waitpid 方法来监听某个或者所有子进程的执行并回收其占据的资源，同时可以获取到该子进程的状态信息。waitpid 方法签名如下：

```c
pid_t waitpid(pid_t pid, int *statusp, int options);
```

### 线程休眠

- sleep(10) 让当前进程休眠 10 秒钟，相当于主动让出 CPU 执行权
- pasue() 休眠当前进程直到被 signal 唤醒

### 加载并执行程序

系统提供了方法用来在运行时加载一个程序，该方法与 main 函数的方法签名相同。
事实上，调用该方法后，系统做的事情就是准备启动程序，调用 main 方法。

```c
int execve(const char *filename, const char *argv[], const char *envp[]);
```

其中，filename 可以是二进制程序或者系统内置命令，argv 是命令行参数，envp 是系统环境变量。

这个程序会直接在当前进程执行，除非报错，否则永远不会返回。。
也就是说，调用这个方法后，当前进程就被传入的 filename 绑架了，只能被该程序独占执行。

这是 Unix 进程模型的重要机制，结合 fork() 可以实现创建子进程然后执行新程序的功能，即 shell 程序。


