## Exceptions

系统定义了一系列异常码，并在内核中维护了一张跳转表，保存了异常码和其对应的处理方法的地址值。

CPU 正常执行指令，然后收到一条中断信号，然后程序会切换到内核态去执行对应的处理方法。

根据具体的异常情况，内核有可能会：

1. 直接去执行异常处理流程，在完成处理后返回继续执行正在处理的指令；
2. 等当前正在执行的指令完成以后，再去执行异常处理流程，然后直接返回下一条指令，好像什么都没有发生过；
3. 严重错误，直接杀进程；

异常分为四类：

1. Interrupts，常见于异步 I/O，等当前指令执行完成后去处理，然后再回来继续执行（有可能和当前程序完全无关）
2. traps，刻意行为，调用系统提供的方法和系统做交互，以获得更大的能力，类似于同步方法调用
3. faults，操作系统尝试修复，修复好继续执行，修复不好 abort
4. aborts，严重错误，杀进程

系统调用是个很重要的话题，x86-64 提供了 syscall 指令来执行系统调用，其中：

- 一共有 256 个不同的异常类型，0-31 是 Intel 定义，32-255 由操作系统定义；
- 开发者并不需要使用 syscall 指令，而是用系统提供的 API 来实现系统调用，比如常见的输入输出、读写文件等
- 在汇编层，系统调用和普通的方法调用也完全不同
    - 调用发生在内核保留区域而不是普通调用栈
    - 参数全部由寄存器管理，不通过栈传递
