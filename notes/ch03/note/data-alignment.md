## 内存对齐

机器本身对数据类型没有概念，只能知道数据的大小，对所有数据都一视同仁，利用地址值进行索引访问。

当对同一块连续内存空间的不同数据进行访问时，比如数组或结构体，机器访问该数据的方式都是：基地址 + 数据大小的偏移量。

地址值的计算都是很简单的加减法，在这种情况下，CPU 对 2 的幂次有天然的支持，只需要进行简单的位运算即可得到结果，但如果是 3、5、7 之类的偏移，则需要多余的计算，效率更低。

内存对齐的价值就在于：确保数据的地址值是其大小的整数倍（不是任意 2 的幂次），从而让 CPU 可以用最少的内存访问次数读取数据。

注意不是所有数据的地址都必须是 2 的幂次，char 类型（1字节）的数据可以位于任何地址。

### 基本原则

内存对齐需要保证几个基本原则：

- 系统在给变量或成员分配固定的内存块时，根据汇编 `.align X` 的配置不同，要确保返回的地址值是 8/16/32 的整数倍
- 对于结构体来说，如果访问某个成员的偏移量不是 2 的幂次，就需要对该成员的前一个成员进行 padding 填充，保证偏移量一定是 2 的幂次
- 整个结构体的大小必须是其最大对齐要求（通常是最大成员大小）的整数倍

以下面的结构体来举例：

```c
struct S {
    char a;
    int c;
    char d;
    double e; 
}
```

根据第一条原则，系统分配给我们的基地址一定是 2 的幂次，比如：`0x08`，则这个地址实际上是成员 `a` 的地址值。

我们在访问每个成员的时候，需要用基地址 + 偏移量来进行访问：

- `a`: 0x08 + 0 (偏移量为 0，该地址就是 a 的地址)
- `c`: 0x08 + 4 (偏移量为 4 而不是 1，对前一个成员的内存空间进行 3 个字节的填充)
- `d`: 0x08 + 8 (偏移量为 4+4=8，前一个成员不需要填充)
- `e`: 0x08 + 12 (偏移量为 4+4+4=12，对前一个成员进行 3 字节填充)

图示如下：

```
0x08    [a---][cccc][d---][eeeeeeee]
        ^     ^     ^     ^
        |     |     |     |
        +0    +4    +8    +12
```

其中：

- `a` 表示 char a 的数据，`-` 表示填充字节
- `c` 表示 int c 的数据
- `d` 表示 char d 的数据
- `e` 表示 double e 的数据

这样一来，这个结构体占据的内存空间就是 20 字节，比表面上看起来的 1+4+1+8=14 字节多了 6 个字节。

### 内存对齐的优化

如前所述，内存对齐的目的是为了提高 CPU 的访问效率，但同时也带来了内存空间的浪费。

因此，在设计结构体时，应该尽量减少不必要的 padding 填充，从而优化内存对齐。

我们可以简单地通过对所有成员按照数据类型的大小进行降序排列，就可以减少 padding 填充。

还以上面的结构体为例，如果我们按照 `double e; int c; char a; char d;` 的顺序排列，则结构体占据的内存空间就是 16 字节，比原来的 20 字节少了 4 个字节。

图示如下：

```
0x08    [eeeeeeee][cccc][a-][d][---]
        ^         ^     ^   ^
        |         |     |   |
        +0        +8    +12 +14
```

其中：

- `eeeeeeee` double 类型放在最前面，满足其 8 字节对齐要求；
- `cccc` int 紧随其后，刚好在 8 字节边界上，满足 4 字节对齐；
- `a-` char 类型在 int 之后，偏移 12 字节可以访问，做 1 字节填充保证后续成员满足对齐要求；
- `d` char 类型，算上上一个成员的填充，可以以偏移 14 字节访问到
- `---` 末尾填充，保证整个结构体满足最大对齐要求

这种声明顺序可以产生更紧凑的内存布局，从而减少内存浪费。

总的来说，在字节对齐的时候有两种情况：

- 成员对齐，类似 `a-` 这种对齐，目的是访问其之后的成员的时候满足 2 的幂次偏移，减少 CPU 索引计算量；
    > 每个成员按照其自身的大小或编译器指定的对齐值进行对齐

- 末尾填充，保证的是整体满足最大成员倍数的对齐要求，保证数组场景下可以正确索引；
    > 整个结构体的大小必须是其最大对齐要求（通常是最大成员的大小）的整数倍

### 内存碎片

内存碎片是指内存中不连续的空间区域，可能是内存对齐过程中的填充区域（内部碎片），或者是多个连续内存空间中间的间隔（外部碎片）。

内存碎片过多会使系统无法最大效率地利用内存资源，导致内存空间的浪费。

所以，保证紧凑的内存布局以及及时释放内存都能缓解这个问题。

系统的垃圾回收的本质也是要保证尽可能少的内存碎片，更好地利用内存空间。同时，还可以通过内存整理，将分散的对象移动到连续空间，从而减少外部碎片，提高内存利用率。

