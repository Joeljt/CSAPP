## 浮点数的机器级表示

浮点数使用专门的 XMM 寄存器（%xmm0 到 %xmm15）。

每个 XMM 寄存器是 128 位的，单精度浮点数使用低 32 位，双精度浮点数使用低 64 位。这些寄存器也可以用于 SIMD（单指令多数据）操作。

在支持 AVX 的处理器上，这些寄存器可以扩展为 256 位的 YMM 寄存器。

### 浮点传送和转换操作

浮点数也有单独的指令进行数据传递的 mov 操作，但在这里暂时不展开。

### 过程调用

XMM 寄存器 %xmm0 ~ %xmm7 最多可以传递 8 个参数，超出的会通过栈传递。

函数使用 xmm0 来返回浮点值。

所有 XMM 寄存器都是 caller-saved，所以可以任意覆盖寄存器而不需要关心数据保存和还原问题。

当函数同时包含指针、整数和浮点数的时候，指针和正数用通用寄存器传递，浮点数用 XMM 寄存器传递。

### 浮点运算操作

与正数运算类似，具体指令暂不展开。

### 浮点常数

与正数一个很大的不同是，浮点数中没有立即数，所有的常量值都需要分配和初始化内存空间。

然后再在代码里把这些值都内存中读入。

注意这里从寄存器中读出的浮点值，仍然满足 IEEE 规范，而不是普通的整数的补码表示。

举例来说：

```assembly
cel2fahr:
  vmulsd  .LC2(%rip), %xmm0, %xmm0  ; multiply 1.8
  vaddsd  .LC3(%rip), %xmm0, %xmm0  ; add 32.0
  ret
.LC2:
  .long   3435973837                ; 1.8 的低 4 位
  .long   1073532108                ; 1.8 的高 4 位
.LC3:
  .long   0                         ; 32.0 的低 4 位
  .long   1077936128                ; 32.0 的高 4 位
```

以 1.8 为例，其中：

- 3435973837 = 0xcccccccd (低32位)
- 1073532108 = 0x3ffccccc (高32位)

合并为64位：0x3ffcccccccccccd

符号位：0 (正数)
指数：3ff (1023)，减去双精度的偏移量 1023 得到 0
尾数：cccccccccccd 二进制小数为 0.8，加上隐含的 1 得到 1.8

### 位运算操作

与正数运算类似，具体指令暂不展开。

### 比较操作

与正数运算类似，具体指令暂不展开。有一点不同是，浮点的比较还会影响 PF 奇偶标记位。具体有需求再深入研究。

可以发现，浮点数的汇编表示与整数整体思路类似，只不过有些细微的差别，比如寄存器不同或者无法表示立即数等。