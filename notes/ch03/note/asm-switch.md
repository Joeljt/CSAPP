## switch 语句在汇编中的表示

switch 语句在汇编语言中的解释，本质上是利用了数组索引 O(1) 复杂度的思路进行优化。

### 基于 jump table 的优化

对于 switch 语句来说，实际上就是在比对 `x == n` 的过程，编译器在优化时，会：

1. 将所有的 case 代码块都封装成独立的 label，支持跳转；
2. 将所有的 case 代码块对应的 label 都按顺序放到一个数组里，即维护一个 [.L1, .L2, .L3, ...] 的数组；
3. 对 case 值进行一定程度的偏移，将其映射为数组的索引值，从而保证能正确定位到各 case 对应的 label 执行跳转；
4. 如果某个 case 不满足匹配条件（没找到），会直接跳转到 default 块对应的 label；
5. 如果多个 case 共用一个代码块，会在数组中对应 case 的位置存放同一个 label；
6. 如果有 case 没有写 break，则生成的汇编代码也没有 `jump` 指令，从而保证顺序向下执行，也就是 fall through 的效果；
    - 注意这里的 fall through 不是实现的效果，而是没有写 break 的表现

### 索引不规律

但是，当 switch 语句的 case 值没有规律并且不集中时，跳表的传统优化方式就不再适用了，因为无法有效地将条件值映射到连续的索引。

因此，编译器会退而求其次，使用其他策略来实现条件判断：

- 哈希表：将 case 值映射到哈希表，通过哈希查找匹配。
- 线性查找：直接对每个 case 值进行逐一比较。
- 分段查找：将 case 值按范围分段查找，减少比较的范围。

#### 哈希映射（Hash Map）

在没有规律的条件下，编译器可能会选择为每个 case 值创建一个哈希表。哈希表可以将 case 的条件值映射到一个位置，从而避免直接通过简单的偏移来访问。这种方式适用于 case 值分布非常离散的情况。

对于每次 switch 检查，编译器会先通过哈希函数计算出该条件值的哈希码，然后在哈希表中找到对应的跳转目标。

示例：

```assembly
; 伪代码：生成哈希表
hash eax, hash_table
cmp eax, hash_value_1043
je case_1043
cmp eax, hash_value_96634
je case_96634 
; 对其他case值类似
```

虽然哈希表在执行时的查找速度通常较快，但它也有开销，比如哈希碰撞处理和额外的内存占用。

### 分支判断（Linear Search）

对于极其稀疏或无规律的条件，编译器最终可能退回到线性查找。即使 switch 的 case 值完全不规律，编译器也能生成一段按顺序比较 case 值的汇编代码。

在这种情况下，编译器会生成一系列的 cmp 指令，逐个比较 switch 值直到找到匹配的分支。

示例：

```assembly
cmp eax, 1043
je case_1043
cmp eax, 96634
je case_96634
cmp eax, 3
je case_3
cmp eax, 99
je case_99
jmp default_case
```

线性查找对于数量较少或条件较简单的 switch 语句来说仍然是一个合理的选择。

### 分段范围查找

如果 case 值并没有规律，但可以划分为不同的范围（例如，某些值集中在某个区间内），编译器可能会通过分段查找来优化性能。

具体来说，编译器可能会尝试将 case 值分成几个区间，并通过区间的判断来缩小搜索范围，从而减少不必要的比较。

比如，先根据值范围判断是进入哪个区间，然后在区间内进行更精确的匹配。

示例：

```assembly
; 假设 case 值分成几个区间
cmp eax, 1000
jl case_less_than_1000
cmp eax, 50000
jge case_greater_than_50000
; 继续判断区间
```

