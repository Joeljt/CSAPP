## 缓冲区溢出攻击

在过程调用时，`call` 指令会把下一条需要执行的指令作为 `return address` 压入当前函数的运行时栈中，然后更新 `%rip` 指针到目标函数所在位置开始执行。

等函数执行完成后，`ret` 指令会把 `return address` 从栈中弹出并更新给 `%rip` 指针，从而回到函数调用前的代码继续执行。

上述过程就是函数调用的完整流程。

但是 C 本身没有对数据的边界做任何限制，不同数据的内存地址都是紧密相连的。

如果有程序有意或者无意地利用这个特点，覆盖了原来的 `return address` 的值，当函数执行完毕尝试返回原来的位置继续执行时，就会跳转到某个覆盖后的值而不是正确的 `return address`。

现代编译器有多种方式来避免或者防范缓冲区溢出攻击，主要有以下几点：

- 随机化内存地址

在以前的系统中，内存地址的分配规则是固定的，在同样架构的系统上，黑客可以非常轻松地预测攻击代码会被分配到具体什么地址值。

在现代系统中，每次运行一个程序时，往往会先在内存空间中先随机生成一个 0～n 大小的内存块。

该内存块不会存储任何内容，只是用来对内存地址做一个初始偏移，从该偏移基础上再向后开辟内存，从而避免内存地址的可预测性。

- 栈破坏检测

gcc 在某些特殊场景下，会在每次程序运行的时候随机生成一个 canary value，并将该值插入到栈空间的 `local variables` 和其他数据中间。

同时，该值被保存在一个无法被覆盖的位置，保证可以被用来比较。

之后，在方法执行完调用 `ret` 指令返回前，会对插入这个 guard value 进行验证，如果被更改了程序就会报错终止运行。

- 限制代码可执行区域

在早期的系统设计中，使用了同一个 bit 位来同时代表读与执行权限，所以只要一个区域可读，就可以执行代码，而栈必须是可读写的，这就暴露了很大的风险。

新版的系统中引入了新的标志位，可以将栈区标记为禁止执行代码，也就可以避免缓冲区溢出攻击行为。

某些语言支持 just-in-time 编译运行，可以动态生成并执行机器码，具体是否限制生成的代码只能在生成区域的内存执行，取决于具体的高级语言的实现。




