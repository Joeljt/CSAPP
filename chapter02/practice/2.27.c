#include <limits.h>

/**
 * 对于计算机来说，不存在符号，只有最基本的二进制加法，所有的符号、负数等都是人为创造的概念。
 * 所以，在进行加法运算时，就正常操作二进制，超过最高位的部分全部丢弃，再根据 32 位二进制数决定最后的结果是什么。
 * 
 * 对于无符号数，如果 x + y = s，但是 s < x 或者 s < y 时，我们就可以认定发生了溢出。
 * 同时，由于 x 和 y 最大值为 2^w - 1，所以 x + y 的最大值为 2*(2^w-1) = 2^(w+1) - 2，不会超过 2^w 
 * 但是由于 int 最大可容纳的值为 2^w - 1，所以超出的部分会被截断，即 >= 2^w 的部分都会被截断，最终的结果就是 res % 2^w。
 * 又因为即使是两个最大值相加，额外可以加的最多也就是 2^w - 1，即 2^w-1 + (2^w-1)，所以截断后最终的计算结果实际上就是减去 2^w。
 *
 * 对于有符号数，则分为正溢出和负溢出：
 * - 两个最大的正数相加，相加的结果会超出 TMax 能表达的值，从而让高位变成 1，最后变成负数；
 *      - 相当于 x + y - 2^w
 * - 两个最小的负数相加，相加的结果会超出 TMin 能表达的值，从而让高位变成 0，最后回到正数；
 *      - 相当于 x + y + 2^w
 */

int uadd_ok(unsigned int x, unsigned int y) {
    // 如果相加的结果比原值还小，说明有溢出
    return x + y >= x;
}

int tadd_ok(int x, int y) {
    int sum = x + y;
    // 两个值都小于 0，但是相加结果大于等于 0，说明有负溢出
    int neg_over = x < 0 && y < 0 && sum >= 0;
    // 两个值都大于 0，但是相加结果小于等于 0，说明有正溢出
    int pos_over = x > 0 && y > 0 && sum <= 0;
    // 这两种情况都不存在，说明一切正常
    return !neg_over && !pos_over;
}

// 这个代码不能有效检测溢出，这是因为即使出现了溢出，sum - x == y 和 sum - y == x 也是成立的
// 因为 (x+y)-x == y，(x+y)-y == x 是恒成立的
// 对于 4 位数字 1011 + 1111 来说：
// 1011 + 1111 = 11010，截断后为 1010
// 二进制减法也是标准减法，不够减时向上借位，只不过借的高位被截断不显示
// 1010 - 1011 = 1111，1010 - 1111 = 1011
// 所以 1010 - 1011 == 1111 和 1010 - 1111 == 1011 都是成立的
// 所以这个代码不能有效检测溢出
int tadd_ok_buggy(int x, int y) {
    int sum = x + y;
    return (sum - x) == y && (sum - y) == x; 
}

// 通过 tadd_ok 检测 x - y 的溢出，因为 x - y 相当于 x + (-y)
// 唯一的特殊情况是 y = TMin，此时 -y 也等于 TMin
// TMin 没有与之相对应的正数，TMin 二进制表示为 1...000，需要加上一个 1...000 才能得到 0
// 所以 TMin 的相反数就是 TMin 本身
// 这种情况下，如果 x < 0，那么 x + (-y) 就会负溢出；如果 x > 0 就一切正常
int tsub_ok(int x, int y) {
    // return tadd_ok(x, -y);
    return tadd_ok(x, -y) || (y == INT_MIN && x < 0);
}
