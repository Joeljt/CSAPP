/**
 * 布尔代数
 * 
 * & 与，两个都为 1 时，结果为 1（集合中的交集）
 * | 或，两个有一个为 1 时，结果为 1（集合中的并集）
 * ~ 非，0 变 1，1 变 0 （集合中的补集）
 * ^ 异或，两个都为 1 的时候，结果为 0（集合中的对称差）
 * 
 * Operation                   Result
 * ---------------------------------------
 * a                           [01001110]
 * b                           [11100001]
 * 
 * ~a                          [10110001]
 * ~b                          [00011110]
 * a&b                         [01000000]
 * a|b                         [11101111]
 * a^b                         [10111111] // 对称差，两个都为 1 的时候它为 0
 * 
 * 异或有一个重要性质：
 * 
 * 1. 对于任意值 a 来说，都有 a ^ a = 0。
 *  这是因为异或的定义是：两个值相同的时候结果为 0，两个值不同的时候结果为 1。
 *  所以，a 异或 a 的时候，两个值完全相同，所以结果一定为 0.
 * 
 * 2. 对于任意值 a 来说，都有 a ^ 0 = a。
 *  这是因为 0 与任何值异或的结果都是那个值本身。
 * 
 * 3. 同时，异或还满足交换律，即 (a ^ b) ^ c = a ^ (b ^ c)。
 */

// 这种写法之所以成立，就是利用了上面提到的三点性质。
void swap(int *a, int *b) {
    // 1. 先将 a 和 b 的值异或，结果赋值给 a，此时 a = a^b
    *a = *a ^ *b;
    // 2. 再次异或并赋值给 b，代入 a = a^b，此时 b = a^b ^ b = a^b^b = a^0 = a
    *b = *a ^ *b;
    // 3. 最后再次异或并赋值给 a，代入 b = a，此时 a = a^b ^ a = a^b^a = b^0 = b
    *a = *a ^ *b;
}

// 对于长度为奇数的数组，反转后中间的元素会变成 0
// 这是因为 first == last 的时候，a[first] 和 a[last] 是同一个元素，此时 x^x = 0
// 所以下面的代码需要改成 first < last 才能正确反转数组
void reverse_array(int a[], int cnt) {
    int first, last;
    for (first = 0, last = cnt-1; first <= last; first++, last--) {
        swap(&a[first], &a[last]);
    }
}