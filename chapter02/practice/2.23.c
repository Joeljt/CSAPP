#include "stdio.h"

/**
 * 1. 对于一个无符号的数字，先左移 24 位，即留下低 8 位；
 * 2. 再右移 24 位；
 * 3. 再强制类型转换为有符号数；
 * 
 * 这个 shift 操作看起来什么都没做，但是对于有符号数，>> 操作是算术右移，高位补的是符号位
 * int 类型转换也有可能会导致溢出问题
 */
int fun1(unsigned word) {
    return (int) ((word << 24) >> 24);
}

/**
 * 在左移之前先强制类型转换为 int，所以在这个过程中可能出现负数，就会影响之后的右移操作
 */
int fun2(unsigned word) {
    return ((int) word << 24) >> 24;
}

void test_2_23() {

    // 左移后变成 0x76，逻辑右移高位补 0，转 int 不影响，结果还是 0x00000076
    printf("%d\n", fun1(0x00000076)); 
    // 左移后变成 0x21，逻辑右移高位补 0，转 int 不影响，结果 0x00000021
    printf("%d\n", fun1(0x87654321));
    // 左移后 0xC9，8-F 开头的高位都是 1，但是这里是无符号数，所以逻辑逻辑高位补 0，结果 0x000000C9
    printf("%d\n", fun1(0x000000C9));
    // 同上，结果 0x00000087
    printf("%d\n", fun1(0xEDCBA987));


    // 转成 int 后不影响符号，算术右移高位补 0，结果 0x00000076
    printf("%d\n", fun2(0x00000076));
    // 转成 int 后变成负数，但是左移后变成正数，算术右移高位补 0，结果 0x00000021
    printf("%d\n", fun2(0x87654321));
    // 转成 int 以后还是正数，但是左移后变成 0xC9，变成了负数，右移时高位补 1，结果 0xFFFFFFC9
    printf("%d\n", fun2(0x000000C9));
    // 同上，结果 0xFFFFFF87
    printf("%d\n", fun2(0xEDCBA987));
}