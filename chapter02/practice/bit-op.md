## 位运算

系统提供了 &、｜、^、~ 四种位级运算，用来直接操作数字的二进制表示。位运算相较于普通的运算，会有更高的性能，在高级的优化场景下非常重要。

  0010            1010            1010        
& 0011          | 0011          ^ 0011          ~ 0011
------          ------          ------          ------
= 0010          = 1011          = 1001          = 1100

### AND

与运算用来对两个数字做交集匹配，两者都为 1 时结果为 1，否则即为 0。

该运算符的常用场景为保留特定位数，比如：

1、0x12345678 & 0xff，就会抹掉高位所有的值，只保留最后两位，即 0x78；
2、对于满足 2 的幂的数组长度，对 len - 1 求与效果等价于取模；
3、对于位运算枚举，经常使用类似 permission & WRITE != 0 来验证是否包含特定配置；

#### 应用

1. 判断奇偶

所有的奇数最低位都是 1，所以对 1 求 &，奇数结果为 1，偶数结果为 0。

```js
const isOdd = (a) => a & 1;
```

2. 获取二进制表示的最低位 1

x 的负数表示为 ~x + 1，原码取反后再加 1。
- 如果原码最低位是 0，那取反后最低位就是 1，再加 1 后，所有低位都为 0，只有最后一个 1 会被保留。
- 如果原码最低位是 1，那取反后最低位就是 0，再加 1 后，所有低位都为 1，只有最后一个 1 会被保留。

因此，x & (-x) 可以用来获取二进制表示的最低位 1。

```js
const getLowestOne = (a) => a & (-a);
```

3. 判断是否为 2 的幂

对于 2 的幂次，其二进制表示为最高位为 1，其余位都是 0。

基于这个特性，有两种方式可以判断是否是 2 的幂次：

第一种，通过上面获取最低位 1 的方式，判断最低位 1 是否是唯一一个 1，即 x & (-x) == x；

```js
const isPowerOfTwo = (a) => a & (-a) == a;
```

第二种，如果 x 是 2 的幂次，那其二进制表示中就只有一个 1。而 x - 1 会把最低位的 1 变成 0，并且把最低位 1 之后的所有位都变成 1。

因此，通过判断 x & (x - 1) 可以确定 x 是否是 2 的幂次，即 x & (x - 1) == 0。同时，x 必须大于 0，因为 0 不是 2 的幂次。

```js
const isPowerOfTwo = (a) => a > 0 && (a & (a - 1)) == 0;
```

### OR

或运算用来对两个数字做并集处理，对应位中只要有一个值为 1，那结果就是 1。

或运算的常用场景为：
1、对两个数字做并集处理，比如：0x12345678 | 0xff，就会抹掉高位所有的值，只保留最后两位，即 0x78；
2、对两个数字做或运算，可以用来将某些位设置为 1，比如：0x12345678 | 0x00000001，可以将最低位设置为 1，即 0x12345679；
    - 1000 ｜ 0001 = 1001 = 9

### EXCLUSIVE_OR

异或运算相当于集合中的非对称匹配，相匹配的两位相等值为 0，不等则为 1。

异或运算有以下几个重要特性：

1. 任何数和 0 做异或运算，结果都是原来的数，即 a ^ 0 = a；
    - 这是因为 0 ^ 0 = 0，0 ^ 1 = 1，所以任何数和 0 做异或运算，结果都是原来的数。
2. 任何数和其自身做异或，结果都为 0，即 a ^ a = 0；
    - 这是因为自己异或自己，就是每一位都是 0^0 或者 1^1，结果都是 0。
3. 交换律：a ^ b = b ^ a;
4. 结合律：(a ^ b) ^ c = a ^ (b ^ c);
5. 自反性：a ^ b ^ b = a;
    - 这是因为 a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a。
6. 对某一位对 1 求异或，就相当于对该位取反，因为 0^1 = 1，1^1 = 0。

#### 应用

1. 交换两个变量（无额外变量）

这种方式本质上就是在利用异或运算的结合律，以及自反性。

```js
a = a ^ b;
b = a ^ b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a;
a = a ^ b = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b;
```

2. 找出数组中唯一的数

数组中只有一个数出现了一次，其他数都出现了两次，找到那个唯一的数。

仍然是利用自反性，a ^ a = 0，所以对数组中的所有数求异或，结果就是唯一的那个数。

```js
for (let i = 0; i < nums.length; i++) {
    res ^= nums[i];
}
```

3. 判断两个数是否相等

同样是利用自反性，一个数异或其自身，结果为 0。

```js
if (a ^ b == 0)
```

4. 计算二进制中 1 的个数

n & (n - 1) 会抹掉最低位的 1，每次抹掉一个 1，就计数一次，这样可以统计出二进制表示中 1 的个数。

```js
let count = 0;
while (n) {
    n = n & (n - 1);
    count++;
}
```

5. 翻转某一位的状态

0 或者 1 对 1 求异或，结果就是取反。这里通过按位偏移后对 1 求异或，可以翻转某一位的状态。

```js
n ^= (1 << i);
```

6. 简单加密和解密

利用自反性，可以在传输侧使用某个值对数据做异或，在接受侧再对同一个值求异或，就可以得到原始数据。

```js
c = a ^ key;
a = c ^ key;
```

### NOT

非运算用来对数字的每一位取反，即 0 变 1，1 变 0。

非运算的常用场景为：
对数字取反，比如：~0x12345678，可以将数字的每一位取反，即 0x12345678 变为 0xedcba987；
    - 注意这里：
        - 对一个数取反，实际上就是在对该数求补码。
        - 对于异或运算，对某一位对 1 求异或，就相当于对该位取反，因为 0^1 = 1，1^1 = 0。
        - 也就是说，对于 a = 0x12345678，a ^ 0xffffffff = ~a。

## 位移运算

位移运算用来对数字的二进制表示进行左移 << 或右移 >> 操作。

左移运算符用来将数字的二进制表示向左移动指定的位数，右边空出的位用 0 填充。

右移分为逻辑右移和算术右移：
1. 逻辑右移：将数字的二进制表示向右移动指定的位数，左边空出的位用 0 填充。
2. 算术右移：将数字的二进制表示向右移动指定的位数，左边空出的位用符号位填充。

在 C 语言中，对于无符号数是逻辑右移，对于有符号数是算术右移。因为无符号数在移动的时候一定要用 0 填充，否则右移操作的语义就变了。

在 Java 中，使用 >>> 表示逻辑右移，使用 >> 表示算术右移（即对于负数使用 1 填充），使用 << 表示左移。这是因为 Java 中没有无符号数，逻辑右移的应用场景很少。

如果移动的位数过大，超过当前数字的位数，程序在实际执行的时候，会对移动位数对数字的位数取模，即移动位数 = 移动位数 % 数字的位数。

比如，一个 32 位对数字，移动 32 位，实际上就相当于没有移动；移动 33 位，就相当于移动 1 位。

另外一个需要注意的点是，位移运算的优先级低于加减运算，高于比较运算。

## 综合应用

日常业务或者系统源码中常见的，基于掩码实现的权限或者类似的功能。

```c
// 对每个权限位进行掩码定义，从 0 开始依次左移
int read = 1 << 0; // 0001
int write = 1 << 1; // 0010
int execute = 1 << 2; // 0100
int delete = 1 << 3; // 1000

// 用 ｜ 运算符对权限进行组合（求集合的并集）
int permission = read | write;

// 同上，用 ｜ 新加权限，因为每个权限都对应一位，所以也不会冲突
void set(int flag) {
    permission = permission | flag;
}

// 用 & 运算符判断是否包含某个权限（求集合的交集）
// 如果结果不为 0，则表示包含该权限
int has(int flag) {
    return permission & flag != 0;
}

// 权限位都只有一个 1，如果对其进行取反操作，则会把当前位变成 0，其他位都是 1
// 然后再对 permission 求与，对 1 求与还是原值，对 0 求与一定是 0，所以相当于是删除了该标志位
// 假设 permission: 1111，flag：0100，取反后为 1011
// 1111 & 1011 = 1011，效果就是把对应的权限位删除了
void clear(int flag) {
    permission &= ~flag;
}

// 因为每个权限位也只有一个 1，所以求异或实际上就是在翻转对应的权限位状态，同时也不影响其他位
// 1. 其他位都是 0，异或到 1 或者 0，都是原值（任何数和 0 异或都是原值）
// 2. 目标位是 1，任何数异或 1 都是对自己取反
// 综上，对单个位 ^= 就是取反操作，所以可以达到开关指定功能的效果
void toggle(int flag) {
    permission ^= flag;
}
```