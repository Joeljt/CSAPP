## 浮点数

### 小数的二进制表示

小数的二进制表示很好理解，与整数的表示一脉相承，只不过小数是 2 的负幂次。

以 $5 \frac{3}{8}$ 为例，其二进制表示为 101.011，计算过程如下：

$$
\begin{align}
1 * 2^2 + 0 * 2^1 + 1 * 2^0 + 0 * 2^{-1} + 1 * 2^{-2} + 1 * 2^{-3} \\
4 + 0 + 1 + 0 + \frac{1}{4} + \frac{1}{8} \\
4 + 1 + \frac{2}{8} + \frac{1}{8} \\
5 + \frac{3}{8}
\end{align}
$$

与整数的二进制表示类似，小数点的移动也是倍数性质。小数点左移一位相当于除以 2，右移一位相当于乘以 2。

由此可见，小数的二进制表示法只能表示那些能够被写成 $x \times 2^y$ 的数，其他值只能近似表示。

也就是说，能用二进制表示的小数，其分母一定是 2 的幂次。

基于这个规律，我们可以把整个数字转换为 $\frac{x}{2^y}$ 的形式，然后把二进制小数插入到从右边算起第 y 个位置就能得到这个小数的二进制表示。

我们先正常表示分子，然后把小数点左移 y 位就相当于执行了除法操作。一个整数乘以一个小于 1 的分数，最终的结果必然是小于原整数的。

以 $\frac{25}{16}$ 为例，我们有 25 = 11001，16 = 2^4，所以我们把小数点放在从右往左数第 4 位，我们就可以得到 1.1001，这就是 $\frac{25}{16}$ 的二进制表示。

增加小数点后的位数可以提高表示的精度，但仍然不能表示所有的小数。

### IEEE 浮点数

普通的二进制表示法不能有效地表示小数，所以 IEEE 浮点数标准定义了一种新的表示法。

该表示法定义为：

$$
V = (-1)^s \times M \times 2^E
$$

以 32 位浮点数 $-12.32$ 为例，其 IEEE 表示为 $(-1)^0 \times 1.54 \times 2^{3}$。

其中：

- s = 1，代表当前是负值；
- M = 1.54，由 1 + 二进制表示中的 frac（低 23 位）得到；
- E = 10，由二进制表示中的 exp（符号位后的 8 位）减去某个偏移量得到；

可以发现，除了 s 确实与二进制表示的最高位对应以外，剩下的 M 和 E 与浮点数的二进制没有对应关系，而是有一套独立的规范来解释二进制的表示。

这里需要明确的一点是，这里的公式定义的是小数的计算方式，而不是小数的二进制表示方式。

以 32 位浮点数为例，我们将这 32 位划分为 3 个不同的部分来对公式中不同的部分进行表示：

$$
[sign(1), exp(8), frac(23)]
$$

其中：

- `sign` 就是最高位符号位，0 表示正数，1 表示负数；
- `exp` 是符号位之后的 8 位，根据这里的不同可以把整个浮点数的表示为不同的分类；
- `frac` 是低 23 位，表示小数点之后的值；

根据 `exp` 的不同，可以分为三种不同的情况：

#### 特殊值

`exp` 全为 1 的时候属于这个范畴，如果 `frac` 全为 0，则表示无穷；如果 `frac` 不为 0，则表示非法值 `NaN`。

#### 标准值（Normalized）

`exp` 不能全为 0，也不能全为 1 时，表示标准值。`exp` 是一个 8 位的无符号数，忽略 0 和 255 两个值，其取值范围是 $[1, 254]$。

在这个基础上，再减去 127 的偏移量，就可以得到 $E$（公式中 2 的指数）的取值范围 $[-126, 127]$。

这里的偏移量是动态计算的，与 `exp` 的位数相关：

$$
127 = 2^{w - 1} - 1 = 2^7 - 1
$$

如果是双精度浮点型，这里的偏移量就是 1023。

我们可以发现，这里 `exp` 的定义实际上是 8 位无符号数，然后通过用 $TMax_7$ 做偏移，把 `exp` 变成了一个 7 位的有符号数，从而保证指数 $E$ 有正负，可以用来表达特别大趋近于无穷的数和特别小趋近于 0 的数。

那问题就是：为什么不直接用 7 位有符号数，而要这么拧巴地用偏移量去做减法得到？具体看[这里](./why-not-signed-exponent.md)。

在标准值的定义中，$M = 1 + frac$，由于我们可以自由调整 $E$ 的大小来移动小数点的位置，保证 M 始终处于 $[1, 2)$ 的区间内，所以这里的 1 一般会省略其表示，而是默认这里有一个 1，这样可以多出来一位表示小数，而不需要浪费这一位去表示这个一定会存在的 1。

举例来说，$5.375$ 的 IEEE 表示为 $(-1)^0 \times 1.01011 \times 2^{2}$，其中 $M = 1.01011$，$E = 2$。

s = 0，所以 sign = 0；

E = 2，也就是 exp - 127 = 2，所以 exp = 129，二进制表示为 10000001。

M = 1 + frac = 1 + 0.01011，也就是说 frac 的值是 0.01011，二进制表示为 0101 1000 0000 0000 0000 000。

所以，$5.375$ 的 IEEE 表示为 0 10000001 01011000000000000000000。

#### 非标准值（Denormalized）

`exp` 全为 0 的时候属于非标准值。

在这种情况下，M 的值会忽略隐含的 1，而是直接使用 frac 的值。

E 的值不会用 0(exp) - 127 = -127，而是用 1 - 127 得到 -126。

这是因为在标准值的计算里，exp 的最小值是 1 而不是 0，所以标准值计算出来的 E 的最小值是 -126，而不是 -127。

我们在非标准值里用 1 做偏移，就能保证非标准值的最大值和标准值的最小值是平滑过渡的，而不会因为 $2^{-126}$ 和 $2^{-127}$ 的差距过大而出现不连续的情况。

由于非标准值不会给 M 加上 1，所以非标准值的取值范围是 [0, 1)，可以用非标准值来表示 0 和非常接近于 0 的值。所有的非标准值的指数都是 -126，2 的 -126 次方是非常非常小，接近于 0 的数。

是 0 还是小数完全取决于 frac 的值。其位于 32 位数的低 23 位，可表示的最大值是 1000000000000000000000000，最小值是 0000000000000000000000000。

我们可以发现，浮点数的表示设计成这样，在不考虑符号位的情况下，低 31 位全部都是无符号值，不论是 exp 还是 frac 的值，这样就保证了我们可以非常方便地对小数进行排序和比较，而不需要考虑因为不同区间的符号位。

### 整型和浮点型的关系

对于整型 12345，二进制表示为 11 0000 0011 1001。

为了构建 IEEE 表示，我们把小数点左移 13 位可以得到 $1.1000000111001 * 2^13$。

- 确定符号位为 0，表示正数

- M = 1 + frac = 1 + 0.1000000111001，补齐 23 位后可以得到 frac 就是 $1000 0001 1100 1000 0000 000$;

2. E = 13 = 140 - 127，所以 exp = 140，二进制表示为 $10001100$；

最终我们可以得到 01000110010000001110010000000000 作为 12345.0 的浮点数表示。

00000000000000000011000000111001
          01000110010000001110010000000000
                   ----------

通过对比我们可以发现，整数的低位可以与浮点数的小数的高位完全对应。前面的 1 无法匹配是因为 IEEE 忽略了隐含的 1.

### 舍入

浮点数只能表达近似值，所以需要有一个合理的方式来确定近似值是多少，这就是舍入。

我们熟悉十进制的四舍五入，但是四舍五入的问题在于，如果数字出现在中间位置，我们总是倾向于让它向上取整。

但是这种方式带来的问题是，以求均值举例来说，如果大量数据都位置中间值，那每次都向上取整的操作会导致最后的结果整体偏大，因为包含了大量的向上舍入的结果。

所以，针对目标数据正好位于上下边界的中间值的情况下，可以考虑向偶数舍入的原则。

比如，对于 13.5 会舍入为 14，而对于 14.5 也会舍入为 14；对于 1.235 舍入到 1.24，对于 1.245 也舍入到 1.24。因为 4 是偶数。

通过这种方式，可以尽可能地保证最终舍入数据的平衡性，避免无脑五入导致不同的数据量下最终的结果失衡。

这个方式也适用于二进制数字。

在二进制表示中，我们可以通过 xxx.yyy1000 的模式来确定一个数字是否位于上下边界的中间。

比如 0.5 的二进制表示是 0.100000...，即 $1/2$。所有位于上下界中间的值，其二进制表示都是 1 后面全是 0 的模式。

所以，我们在具体舍入的时候，需要：

1. 确认当前要舍入的位是否是 .xxx1000 的形式；
    - 如果不是，直接看当前要舍入的值是 0 还是 1，0 直接舍去，1 操作进位即可；

2. 确定当前要舍入的位位于正中间，就检查要舍入的位是偶数还是奇数。
    
    - 如果是 0，表示是偶数，直接舍弃；
    - 如果是 1，表示是奇数，进位 +1；

以保留两位小数为例：

1. `10.10011` 舍入为 `10.10`，不在中间位，不需要进位；
2. `10.10101` 舍入为 `10.11`，不在中间位，但是需要进位；
3. `10.10100` 舍入为 `10.10`，在中间位，要舍入的位是偶数，可以直接丢弃；
4. `10.01100` 舍入为 `10.10`，在中间位，要舍入的位是奇数，需要进位；
5. `10.11100` 舍入位 `11.00`，在中间位，要舍入的位是奇数，进位直到不能进为止；

### 运算

由于浮点数实际上表示的都是近似值，在操作的时候会不停的进行舍入，这就导致在某些数学上成立的场景下，对于浮点数实际上不成立。因为舍入会导致精度丢失。

但是由于浮点数实际上并不是严格的位运算，而是将所有位分割后进行计算，这就导致浮点数的运算不存在溢出的情况。

对于两个很大的浮点数计算，exp 溢出变成 1 之后，数字会变成正负无穷或者 NaN，而不是像整数一样溢出。

同样，因为不是单纯的位级运算，所以很多乘法的结合律对于浮点数的计算都是生效的。