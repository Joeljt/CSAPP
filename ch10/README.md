## 系统级 I/O

### Unix I/O

所有高级语言都提供了标准输入输出接口，用来从键盘等外部设备输入到内核，向文件、终端或者显示器输出内容。
但是有时需要利用 Unix 提供的 I/O 接口获取更详细的信息。
同时，了解系统 I/O 对串联之前的知识也很有帮助。

在 Unix 系统中，所有设备都被映射为文件显示，这让 Unix 可以对外提供一套标准的接口：

1. 打开文件
2. 改变文件位置
3. 读取和写入文件
4. 关闭文件

Unix 会给在打开文件时返回一个大于 0 的文件标识符，所有后续操作都依赖该标识符定位该文件。
每个进程在创建的时候都会默认打开三个文件，分别是：标准输入（0）、标准输出（1）和标准错误（2）。
当调用 close 关闭文件或者打开文件的进程死掉的时候，系统会将其资源和对应的文件标记符都回收。

此外，所有文件都有一个类型属性：

- 普通文件
    - 在系统级别，文本文件或者可执行文件没有任何区别，都是二进制文件
- 文件夹
    - 文件夹是一个 link 的列表，每个 link 都是对一个文件或者一个文件夹的映射
    - 每个文件夹至少有两个值，dot 表示到自身的映射，dot-dot 表示到上级文件夹的映射
- socket
    - 在通过网络与其他进程进行通信时使用的文件
- 等等

### 打开/关闭

```c
int open(char *filename, int flags, mode_t mode);
int close(int fd);
```

指定文件名打开，系统会返回一个文件标记符，之后可以基于该标记符进行各种文件读、写以及关闭操作。

其中：

- flags 用来指定读写权限以及默认行为，并且可以用 ｜合并多个动作。
    - 比如 O_WRONLY|O_APPEND 表示以可读写、向文件末尾追加的方式打开某个文件。
- mode 用来指定用户访问权限，比如所有者可读写，其他人只读等；

### 读/写

```c
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
```

基于某个文件标记符，从该文件中读取长度为 n 的内容，写入内存 buf，或者将 buf 的值（最大长度为 n ）写入该文件。

### 读取文件 metadata

```c
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

通过调用上面两个方法可以获取对应文件的元信息，其中 stat 是系统提供的结构体，包含了各种关于文件本身的信息。
这两个方法也没有本质区别，只不过一个接收文件名，一个接收文件描述符。

### 读取目录信息

如前所述，文件夹本质上是个列表，其中维护了一组文件数据，可能是文件，也可能是另一个文件夹。

```c
DIR *opendir(const char *name);
int closedir(DIR *dirp);

struct dirent *readdir(DIR *dirp);
struct dirent {
    ino_t d_ino;       /* inode number */
    char  d_name[256]; /* Filename */
}; 
```


调用上面的方法可以打开某个文件夹，并返回指向第一个节点的指针信息，然后遍历该指针直到 NULL 就可以得到文件夹中的所有内容。

### 共享文件

为了高效地为不同进程维护文件系统的信息，Linux 维护了几个独立又相互关联的结构：

- 每个进程都独立维护的文件描述符列表，其中存储的是指向文件表的指针；
    - 每一项的数组下标就是返回的文件描述符
- 所有进程共享的系统级文件表，记录了文件当前的状态，包括当前读写位置、访问模式、指向 inode 表的指针等
    - 除此之外，还维护了每个文件的引用计数，每次关闭一个文件都会 -1，引用计数为 0 时系统会回收该项；
- 所有进程共享的真实文件的数据信息，包括权限、大小、磁盘上的位置等
    - 不同进程打开同一个文件，它们的文件描述符可能只能同一个 inode

需要注意的是，文件的偏移量会随着 API 的访问以及参数改变，并且固定在对应的位置上，直到下一次访问。
比如 Read(fd1, &c, 1); 会将偏移量向前移动一个字节，下次再访问同一个文件就会从下一个字节，而不是从头开始。

### I/O 重定向

Linux 提供了一些操作符用来重定向输入输出的方向。

ls > foo.txt 会将 ls 命令的结果重定向输出到 foo.txt 文件中

int dup2(int oldfd, int newfd);

将 oldfd 指向 newfd 的文件表，操作完成后两个描述符指向完全一样。

### 标准 I/O

C 语言对 Unix I/O 提供了一系列封装，包括 fopen/fclode, fread/fwrite(bytes), fgets/fputs(strings), scanf/printf。

这些方法的操作对象被抽象为了 FILE 结构，主要是对系统返回的文件描述符以及 buffer 的封装。

每个进程默认都持有三个标准stdin/stdout/stderr, 分别对应 0/1/2 三个默认开启的输入、输出和错误文件描述符。
缓冲区则是为了预加载部分数据，以提高访问效率。

### 最佳实践

1. 尽量使用 C 提供的标准输入输出方法，而不是直接调用系统调用；
2. 不要使用 scanf / rio_readlineb 等方法读二进制文件；
3. 使用 RIO 操作 socket，因为 C 方法在多线程场景下有缺陷，a recipe for disaster；

