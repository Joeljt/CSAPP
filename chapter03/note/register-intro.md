## 寄存器的基本表示

寄存器是集成在 CPU 内部的元件，用来短暂存储加法器等其他硬件计算得到的结果，多个寄存器可能存储多个结果，从而使复杂任务的完成变得可能。

寄存器是 CPU 进度数据处理的核心元件之一。数据从磁盘上被读取到内存中，再从内存读取到高速缓存，再从缓存中存储在寄存器中，方便 CPU 进行计算处理。

### 寄存器的演进和分类

最早的 8086 CPU 有 8 个 16 位寄存器，每个都根据各自的用途有不同的名称，分别是：

| 16-bit 寄存器 | 用途 |
| -------------- | ---- |
| %ax            | 累加器（Accumulator） |
| %bx            | 基址（Base） |
| %cx            | 计数器（Counter） |
| %dx            | 数据（Data） |
| %si            | 源索引（Source Index） |
| %di            | 目标索引（Destination Index） |
| %bp            | 基址指针（Base Pointer） |
| %sp            | 堆栈指针（Stack Pointer） |

其中：

前 4 个寄存器（%ax、%bx、%cx、%dx）主要用于计算。
后 4 个寄存器（%si、%di、%bp、%sp）通常用于地址计算和栈操作。

同时，一个 16 位寄存器可以拆分为两个 8 位寄存器来使用，例如 %ax 可以拆分为 %al 和 %ah，表示高 8 位和低 8 位。

之后，在 32 位的 CPU 中，原本的 16 位寄存器也被扩展为了 32 位，原本的 8 个寄存器也统一增加了 `extended` 前缀，被更名为：

```
%eax %ebx %ecx %edx %esi %edi %ebp %esp
```

之后，64 位 CPU 中，所有的寄存器都扩展为 64 位，并使用 `r` 前缀来表示，并额外增加了 8 个寄存器:

```
%rax %rbx %rcx %rdx %rsi %rdi %rbp %rsp
%r8  %r9  %r10 %r11 %r12 %r13 %r14 %r15
```

需要注意的是，前 8 个寄存器只是出于兼容性考虑沿用旧的名称，但实际上已经不再有原本的含义。

同时，所有新架构的寄存器都向前兼容，但是新增的寄存器与旧的命名规范有所不同。拿 `%rax` 和 `%r8` 举例来说：

- `%rax` 是 64 位寄存器，`%r8` 是 64 位寄存器
- `%eax` 是 32 位寄存器，`%r8d` 是 32 位寄存器
- `%ax` 是 16 位寄存器，`%r8w` 是 16 位寄存器
- `%al` 是 8 位寄存器，`%r8b` 是 8 位寄存器

在 x86-64 中，所有的寄存器都支持上述的拆分和组合，包括栈寄存器 `%rsp` 和 `%rbp`。

注意 `%r8` 在表示不同位时候的后缀有所不同，d、w 和 b 分别对应 double word（32 位）、word（16 位） 和 byte（8 位）。

不过，在 x86-64 体系结构中：

- byte 指 8 位，1 字节，汇编指令中表示为 `b`
- word 指 16 位，2 字节，汇编指令中表示为 `w`
- double word（dword） 指 32 位，4 字节，汇编指令中表示为 `l` (因为 32 位系统时代，双字叫 long words)
- quad word（qword） 指 64 位，8 字节，汇编指令中表示为 `q`

注意这里容易混淆的地方：

- 由于需要向后兼容，所以汇编指令是不能改动的，双字始终表示为 `l`，无论在什么机器上都一样；
    - `movl %eax, %ebx    # 32 位操作`
- 同样是兼容原因，最初的 8 个寄存器，名字以及表示低位的命名方式都保持不变
    - `%rax(64)` / `%eax(32)` / `%ax(16)` / `%al(8)`
- 新增的 8 个寄存器按照新的命名规范进行表示
    - `%r8(64)` / `%r8d(32)` / `%r8w(16)` / `%r8b(8)`
    - 这里没有沿用 `l` 是因为和表示 8 位的 `l` 有可能产生歧义，`%8l` 会让人认为是低 8 位而非 32 位；
- 对于 64 位本身，寄存器的命名没有和汇编指令一样使用 `q` 后缀，而是直接用寄存器名表示
    - `movq %rax, %r8`

这里对 64 位寄存器的命名又是一个错误的设计，未来如果需要扩展到 128 位，因为没有 q 后缀，又要新增规则进行判断兼容逻辑，会让这里的名称问题变得更难理解。