## x86-64 汇编

汇编语言是距离机器码最近的语言，虽然各种各样的高级语言有不同的设计，但是多少都和汇编语言有些联系。

一般来说，汇编语言使用助记符（mnemonic）表示机器指令，并允许程序员直接控制 CPU 和内存。

不同的 CPU 采用不同的指令集（ISA），因此它们的汇编代码通常不兼容，但可以通过中间层实现跨架构兼容性。

比如使用模拟器模拟不同架构的 CPU、高级语言利用编译器（GCC）或者虚拟机（JVM）进行转换，从而运行在不同的架构终端上。

同一个指令集的不同厂商实现是彼此兼容的，比如 Intel 和 AMD 都使用 x86-64，所以即使它们的 CPU 设计不同，程序依然可以跨 CPU 运行。

### 指令操作数

像方法调用需要传递参数一样，汇编的指令调用也需要给具体的指令指令参数，比如为某个寄存器进行赋值操作，就需要指定寄存器和具体的值。

这里操作数的来源可以汇总为三类：

#### 常量（immediate）

这种情况下需要增加 `$` 前缀，用来表示当前是一个常量，可以直接使用，比如 `$-577` 或 `$0x1F`。

#### 寄存器

寄存器中存储的就是某个需要的值，可以直接拿来使用，比如 `%rax`，直接写寄存器的名称即可。

#### 内存

此时，寄存器中存储的是某个内存地址（effective address），我们应该读取该地址的值，而不是直接用寄存器的值。

寄存器访问内存的场景是最常见的，具体的形式也有很多的变种，但最通用的是：$Imm(r_b, r_i, s)$。

$Imm(r_b, r_i, s)$ 最终指向的地址是 $Imm$ + $r_b$ + $r_i \times s$。

所谓的基址寻址、索引寻址、间接寻址等，实际上只是该公式的特殊情况，它们之间的区别主要是为了方便理解和使用，而不是计算上的本质区别。

参考 [这里](assembly-addressing.md) 了解 x86-64 内存寻址中不同部分的语义。

同时，在 x86-64（64 位模式）下，`(%ebx)` 是不合法的操作数，必须使用 64 位寄存器（如 `(%rbx)`）作为内存地址。

### 指令集

汇编语言的核心就是指令集，这里整理一些书中提到的比较常见的指令集以及相应的特性。

如前所述，出于兼容性考虑，为了让基于 16 位或 32 位系统开发的程序也能正常运行在 64 位系统上，64 位寄存器可以拆分为多个低位使用。

同时，根据操作数据的大小不同，每个指令都有对应的带有数据大小后缀的指令。

在现代系统中，一般不会在同一个寄存器中存储多个数据，虽然同一个指令针对不同的数据大小都不同的版本，但也都是处于性能和优化角度使用的。

举例来说，一个 64 位寄存器中存储 char 类型，如果完整访问 64 位，实际上高位的 54 位都是浪费的，因为根本就不会用到。

#### 数据处理指令

将数据在不同的寄存器之间进行移动并处理，最常用的就是 `mov S, D` 指令。其中，S 是数据源，D 是目标位置。

根据不同的数据大小以及相应的用途，`mov` 指令有如下几个分身：

- `movb`(8位) / `movw`(16位) / `movl`(32位) / `movq`(64位)
- `movzbw` / `movzbl` / `movzbq` / `movzwl` / `movzwq`
- `movsbw` / `movsbl` / `movsbq` / `movswl` / `movswq` / `movslq`
- `movabsq` / `cltq`

关于 mov 指令的几个特点：

1. `mov S, D` 的 S 和 D 不能同为内存地址。对于把一个内存地址的值赋值给另一个内存地址，需要两个 mov 指令才能实现；
2. `movb` 和 `movw` 只会操作目标寄存器的指定位，而不更新高位；
3. `movl` 在写入寄存器时会隐式清零高 32 位，但写入内存时不会影响未覆盖的字节；
4. `movzxx` 和 `movsxx` 用于处理较小值赋值到较大值时的高位扩展问题，z 代表 0 扩展，s 代表符号位扩展。
5. `movzxx` 里没有 `movzlq`，是因为可以直接用 `movl` 的隐式清零高 32 位来实现，不需要额外引入指令；
6. `movabsq` 来处理 64 位的立即数，因为`movq` 被限制最多只能处理 32 位立即数；
7. `ctlq` 用来将 `%eax` 符号扩展到 `%rax`，等价于 `movslq %eax, %rax`；

举例来说：

```assemble
movabsq $0x0011223344556677, %rax   ; %rax = 0x0011223344556677
movb    $0xAA, %dl                  ; %dl = AA

movb    $-1, %al                    ; %rax = 0x00112233445566FF
movw    $-1, %ax                    ; %rax = 0x001122334455FFFF
movl    $-1, %eax                   ; %rax = 0x00000000FFFFFFFF，movl 会隐式清零高 32 位
movq    $-1, %rax                   ; %rax = 0xFFFFFFFFFFFFFFFF

movzbq  $dl, %rax                   ; %rax = 0x00000000000000AA
movsbq  $dl, %rax                   ; %rax = 0xFFFFFFFFFFFFFFAA
```

#### 栈管理指令

栈结构在程序的执行过程中起着至关重要的作用，这里介绍入栈和出栈两个指令。

`%rsp` 是比较特殊的一个寄存器，它用来维护方法或函数的执行状态，主要靠它在固定的调用栈区间内上下移动来维护。

操作系统会为每个进程/线程分配自己的栈空间，让其在自己的栈空间内维护函数调用信息。

一般来说，栈会从从某个高地址开始向下，`%rsp` 就指向该地址，每次入栈新元素向下移动栈指针，出栈元素时向上移动栈指针。如果超出栈指针指向超出系统划定的范围，就是栈溢出。

- `pushq S`

压栈操作包含两个动作：1、将栈指针向下移动 8 个字节；2、将目标元素写入栈指针寄存器。

`pushq %rbp` 等价于下面两条指令：

```assemble
subq $8, %rsp
movq %rbp, (%rsp)
```

注意这里寄存器 `%rbp` 指的就是指令中的 S，这里是将先给新加入的元素开了 8 字节的空间，然后将 `%rbp` 的值复制给了栈指针，完成压栈。

- `popq D`

出栈操作与入栈相反，将当前栈指针指向的内容赋值给 D 寄存器，然后将栈指针回退 8 个字节。

`popq %rax` 等价于：

```assemble
movq (%rsp), %rax 
addq $8, %rsp
```

注意这里只是把栈指针回退了 8 字节，而没有清空上次入栈的时候存储的值。完全依赖栈指针的指向来确定栈顶，之前的数据不会进行处理。

#### 算术运算指令

算术运算指令主要用来处理简单的算术计算，主要包括一元运算、二元运算、移位运算以及 leaq 指令。

以下所有全大写的指令表示的都是具体的分类，实际上每个指令都和 MOV 指令一样，根据不同的数据大小都对应的后缀。

- `INC D`，D++
- `DEC D`，D--
- `NEG D`，D = -D
- `NOT D`，D = ~D

- `ADD S, D`，D = D + S
- `SUB S, D`，D = D - S
- `IMUL S, D`，D = D * S
- `XOR S, D`，D = D ^ S
- `OR S, D`，D = D | S
- `AND S, D`，D = D & S

- `SAL k, D`，D = D << k
- `SHL k, D`，D = D << k
- `SAR k, D`，D = D >> k，算术右移，高位补符号位
- `SHR k, D`，D = D >> k，逻辑右移，高位补 0

- `leaq S, D`，D = &S，leaq 主要用来做地址运算，不会访问该地址的内容

对于位移操作来说，k 的取值可以是立即数或者寄存器 `%cl` 的值。`%cl` 最多存储 8 位，最多能够表示 255，远超有可能操作的 64 位。

在实际应用中，对于特定大小的数据，用该数据的位数对 2 取 log，得到二进制下最多多少位能表示该值，得到真正有效的位移位数，然后从 `%cl` 中取出对应的位数做运算。

或者说，是用 `%cl` 最大能表示的 255，对目标数据的位数取模，就能保证超出当前数据有效位数的值都被截断，最终的结果就是正确的。

比如，假设 `%cl` 的值为 0xFF，则有：

- `salb` 操作 8 位数据，2^3 = 8，也就是 `%cl` 的末尾三位，即 0b111，就是 7；
- `salw` 操作 16 位数据，2^4 = 16，也就是 `%cl` 的末尾四位，即 0b1111，就是 15；
- `sall` 操作 32 位数据，2^5 = 32，也就是 `%cl` 的末尾五位，即 0b11111，就是 31；
- `salq` 操作 64 位数据，2^6 = 64，也就是 `%cl` 的末尾六位，即 0b111111，就是 63；

当然，这里只是说明 `%cl` 中存储的值超出有效位数的情况下，系统会怎么处理。

正常情况下，因为系统设计的问题，如果移位的位数无法有效确认的情况下，只能将该动态值存在 `%cl` 寄存器中，而即便是对于最大的值来说，8 位能表示的数字也足够表示要移动的位数。

#### 条件标记

在 x86-64 体系结构中，Condition Code (CC) 或者说状态标志并不是存储在 16 个通用寄存器（如 %rax, %rbx, %rcx 等）中，而是存储在 RFLAGS 寄存器（或者在 32 位架构中是 EFLAGS 寄存器）。

`RFLAGS` 是一个 64 位寄存器，其中 低 32 位（`EFLAGS`）存储了 CPU 的状态标志。

关键的 Condition Code 标志列举如下：

- CF（Carry Flag）：进位标志，最近的一次计算是否有进位或者借位，指示无符号运算的进位或借位。
- ZF（Zero Flag）：零标志，最近的一次计算结果是否为 0。
- SF（Sign Flag）：符号标志，最近的一次计算结果是否为负。
- OF（Overflow Flag）：溢出标志，最近的一次计算是否有溢出，正溢出或者负溢出都算。

这些 Condition Code 并不存储在通用寄存器（%rax, %rbx 等）中，而是单独存储在 RFLAGS 寄存器中，并且由 ALU 计算结果时自动更新。

算术运算指令中，除了 `leaq` 以外的所有指令都可能更改上面的标记位。

此外，系统还提供了两组指令进行数据的判断，其运算结果不会影响指令的参数，但是会更新标记位：

- `CMP S_1, S_2`，该指令的效果是 `S_2 - S_1`，但是不会更新 `S_1` 或 `S_2` 的值；
- `TEST S_1, S_2`，该指令的效果是 `S_2 & S_1`，但是不会更新 `S_1` 或 `S_2` 的值；

举例来说，如果 S_1 与 S_2 相等，则二者相减的值为 0，ZF 标记位就会被设置为 1。

对于标记位的使用，一般有三种方式：

1. 根据某个标记位的状态，给寄存器或者内存中写入 0 或者 1，之后再使用该值做后续处理；
2. `jmp` 等跳转命令会默认读取特定的标记位组合，从而确定前一个运算的结果，以此来控制程序的执行顺序；
3. 根据标记位状态做判断，有条件地进行数据的传递和变更；

对于第一种方式，x86-64 提供了 `SET D` 指令集来进行读取和写入动作。

该指令集下有一系列指令，每个指令会读取特定的标记位组合，以此来确定前一个运算的结果并存入 `D` 中。

需要注意的是，`SET` 指令集的后缀是各种不同的条件，而不是操作数的大小；同时，可能会有多个指令表示同一个动作，编译器会随机选择用哪个指令。

- `sete(setz) D`, `D ← ZF`, Equal / zero
- `setne(setnz) D`, `D ← ~ZF`, Not equal / not zero

- `sets D`, `D ← SF`, Negative 
- `setns D`, `D ← ~SF`, Nonnegative

- `setg(setnle) D`, `D ← ~(SF ^ OF) & ~ZF`, Greater (signed >)
- `setge(setnl) D`, `D ← ~(SF ^ OF)`, Greater or equal (signed >=)
- `setl(setnge) D`, `D ← SF ^ OF`, Less (signed <)
- `setle(setng) D`, `D ← (SF ^ OF) | ZF`, Less or equal (signed <=)

- `seta(setnbe) D`, `D ← ~CF & ~ZF`, Above (unsigned >)
- `setae(setnb) D`, `D ← ~CF`, Above or equal (unsigned >=)
- `setb(setnae) D`, `D ← CF`, Below (unsigned <)
- `setbe(setna) D`, `D ← CF | ZF`, Below or equal (unsigned <=)

可以发现，每个指令都是在读取条件标记位的值，然后进行一系列的位运算后得到某个结果（0 或者 1），再存入 `D`（寄存器或内存）的低位。

以一个判断两个 long 类型 `a < b` 为例：

```c
int comp(long a, long b)
```

其中，a 的值位于 `%rdi`，b 的值位于 `%rsi`，汇编代码如下：

```asm
cmpq    %rsi, %rdi  ; 比较 a 和 b 的大小，注意这里的顺序，需要让 a 在第二个参数
setl    %al         ; 上一条指令会修改条件标记，这里去读取对应的标记位得到 0 或 1，并将其设置给 %rax 的低 8 位
movzbl  %al, %eax   ; 通过零扩展清空低 16 到低 32 位，同时隐式清空高 32 位，最后 %rax 的结果就是 0 或者 1
```

注意这里的比较，实际上计算的是 `a - b`。

在 two's complement 的表示下，`a - b` 的结果可以表示所有条件标记。

比如说：

- 如果 a 和 b 相等，那 `a - b` 的结果就是 0，`ZF` 标记会设置为 1 表示上次计算结果为 0，即表示两个值相等
- 如果 a 小于 b，那 `a - b` 的结果就是负数，也就是 `SF` 会标记为 1 表示上次计算结果为负，即表示 a < b

#### 跳转指令

程序中的各种条件判断会改变代码的执行走向，这在汇编中是依靠 jump 指令集实现的。

汇编代码会为不同的代码块增加不同的 label 用来区分，然后在执行到具体的判断逻辑后，jump 指令集则可以根据条件标记的变化决定是否执行跳转。

jump 指令集分为几个大类：

- 无条件跳转
    - `jmp Label`，直接跳转，会直接忽略后续指令，从 `Label` 标记的指令继续执行
    - `jmp *Operand`，间接跳转，会先计算 `Operand` 的值，可能是寄存器也可能是内存，然后从该值对应的位置继续执行

- 条件跳转
    - `je/jne Label`
    - `js/jns Label`
    - `jg/jge/jl/jle Label`
    - `ja/jae/jb/jbe Label`

条件跳转和上面的条件标记完全对应，只有满足对应条件的时候才会执行。条件跳转不支持间接跳转。

编译器在将 C 代码编译为汇编时，会根据具体的代码实现来优化对 jump 指令的目标的编码。[根据跳转目标位置距离当前位置的远近，可能使用 1/2/4 字节来对目标地址进行编码。](asm-jump-ins.md)