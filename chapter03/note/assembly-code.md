## x86-64 汇编

汇编语言是距离机器码最近的语言，虽然各种各样的高级语言有不同的设计，但是多少都和汇编语言有些联系。

一般来说，汇编语言使用助记符（mnemonic）表示机器指令，并允许程序员直接控制 CPU 和内存。

不同的 CPU 采用不同的指令集（ISA），因此它们的汇编代码通常不兼容，但可以通过中间层实现跨架构兼容性。

比如使用模拟器模拟不同架构的 CPU、高级语言利用编译器（GCC）或者虚拟机（JVM）进行转换，从而运行在不同的架构终端上。

同一个指令集的不同厂商实现是彼此兼容的，比如 Intel 和 AMD 都使用 x86-64，所以即使它们的 CPU 设计不同，程序依然可以跨 CPU 运行。

### 指令操作数

像方法调用需要传递参数一样，汇编的指令调用也需要给具体的指令指令参数，比如为某个寄存器进行赋值操作，就需要指定寄存器和具体的值。

这里操作数的来源可以汇总为三类：

#### 常量（immediate）

这种情况下需要增加 `$` 前缀，用来表示当前是一个常量，可以直接使用，比如 `$-577` 或 `$0x1F`。

#### 寄存器

寄存器中存储的就是某个需要的值，可以直接拿来使用，比如 `%rax`，直接写寄存器的名称即可。

#### 内存

此时，寄存器中存储的是某个内存地址（effective address），我们应该读取该地址的值，而不是直接用寄存器的值。

寄存器访问内存的场景是最常见的，具体的形式也有很多的变种，但最通用的是：$Imm(r_b, r_i, s)$。

$Imm(r_b, r_i, s)$ 最终指向的地址是 $Imm$ + $r_b$ + $r_i \times s$。

所谓的基址寻址、索引寻址、间接寻址等，实际上只是该公式的特殊情况，它们之间的区别主要是为了方便理解和使用，而不是计算上的本质区别。

参考 [这里](assembly-addressing.md) 了解 x86-64 内存寻址中不同部分的语义。

同时，在 x86-64（64 位模式）下，`(%ebx)` 是不合法的操作数，必须使用 64 位寄存器（如 `(%rbx)`）作为内存地址。

### 指令集

汇编语言的核心就是指令集，这里整理一些书中提到的比较常见的指令集以及相应的特性。

如前所述，出于兼容性考虑，为了让基于 16 位或 32 位系统开发的程序也能正常运行在 64 位系统上，64 位寄存器可以拆分为多个低位使用。

同时，根据操作数据的大小不同，每个指令都有对应的带有数据大小后缀的指令。

在现代系统中，一般不会在同一个寄存器中存储多个数据，虽然同一个指令针对不同的数据大小都不同的版本，但也都是处于性能和优化角度使用的。

举例来说，一个 64 位寄存器中存储 char 类型，如果完整访问 64 位，实际上高位的 54 位都是浪费的，因为根本就不会用到。

#### 数据处理 mov

将数据在不同的寄存器之间进行移动并处理，最常用的就是 `mov S, D` 指令。其中，S 是数据源，D 是目标位置。

根据不同的数据大小以及相应的用途，`mov` 指令有如下几个分身：

- `movb`(8位) / `movw`(16位) / `movl`(32位) / `movq`(64位)
- `movzbw` / `movzbl` / `movzbq` / `movzwl` / `movzwq`
- `movsbw` / `movsbl` / `movsbq` / `movswl` / `movswq` / `movslq`
- `movabsq` / `cltq`

关于 mov 指令的几个特点：

1. `mov S, D` 的 S 和 D 不能同为内存地址。对于把一个内存地址的值赋值给另一个内存地址，需要两个 mov 指令才能实现；
2. `movb` 和 `movw` 只会操作目标寄存器的指定位，而不更新高位；
3. `movl` 在写入寄存器时会隐式清零高 32 位，但写入内存时不会影响未覆盖的字节；
4. `movzxx` 和 `movsxx` 用于处理较小值赋值到较大值时的高位扩展问题，z 代表 0 扩展，s 代表符号位扩展。
5. `movzxx` 里没有 `movzlq`，是因为可以直接用 `movl` 的隐式清零高 32 位来实现，不需要额外引入指令；
6. `movabsq` 来处理 64 位的立即数，因为`movq` 被限制最多只能处理 32 位立即数；
7. `ctlq` 用来将 `%eax` 符号扩展到 `%rax`，等价于 `movslq %eax, %rax`；

举例来说：

```assemble
movabsq $0x0011223344556677, %rax   ; %rax = 0x0011223344556677
movb    $0xAA, %dl                  ; %dl = AA

movb    $-1, %al                    ; %rax = 0x00112233445566FF
movw    $-1, %ax                    ; %rax = 0x001122334455FFFF
movl    $-1, %eax                   ; %rax = 0x00000000FFFFFFFF，movl 会隐式清零高 32 位
movq    $-1, %rax                   ; %rax = 0xFFFFFFFFFFFFFFFF

movzbq  $dl, %rax                   ; %rax = 0x00000000000000AA
movsbq  $dl, %rax                   ; %rax = 0xFFFFFFFFFFFFFFAA
```