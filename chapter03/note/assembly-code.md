## x86-64 汇编

汇编语言是距离机器码最近的语言，虽然各种各样的高级语言有不同的设计，但是多少都和汇编语言有些联系。

一般来说，汇编语言使用助记符（mnemonic）表示机器指令，并允许程序员直接控制 CPU 和内存。

不同的 CPU 采用不同的指令集（ISA），因此它们的汇编代码通常不兼容，但可以通过中间层实现跨架构兼容性。

比如使用模拟器模拟不同架构的 CPU、高级语言利用编译器（GCC）或者虚拟机（JVM）进行转换，从而运行在不同的架构终端上。

同一个指令集的不同厂商实现是彼此兼容的，比如 Intel 和 AMD 都使用 x86-64，所以即使它们的 CPU 设计不同，程序依然可以跨 CPU 运行。

### 指令操作数

像方法调用需要传递参数一样，汇编的指令调用也需要给具体的指令指令参数，比如为某个寄存器进行赋值操作，就需要指定寄存器和具体的值。

这里操作数的来源可以汇总为三类：

#### 常量（immediate）

这种情况下需要增加 `$` 前缀，用来表示当前是一个常量，可以直接使用，比如 `$-577` 或 `$0x1F`。

#### 寄存器

寄存器中存储的就是某个需要的值，可以直接拿来使用，比如 `%rax`，直接写寄存器的名称即可。

#### 内存

此时，寄存器中存储的是某个内存地址（effective address），我们应该读取该地址的值，而不是直接用寄存器的值。

寄存器访问内存的场景是最常见的，具体的形式也有很多的变种，但最通用的是：$Imm(r_b, r_i, s)$。

$Imm(r_b, r_i, s)$ 最终指向的地址是 $Imm$ + $r_b$ + $r_i \times s$。

所谓的基址寻址、索引寻址、间接寻址等，实际上只是该公式的特殊情况，它们之间的区别主要是为了方便理解和使用，而不是计算上的本质区别。

参考 [这里](assembly-addressing.md) 了解 x86-64 内存寻址中不同部分的语义。

同时，在 x86-64（64 位模式）下，`(%ebx)` 是不合法的操作数，必须使用 64 位寄存器（如 `(%rbx)`）作为内存地址。

### 指令集

汇编语言的核心就是指令集，这里整理一些书中提到的比较常见的指令集以及相应的特性。

如前所述，出于兼容性考虑，为了让基于 16 位或 32 位系统开发的程序也能正常运行在 64 位系统上，64 位寄存器可以拆分为多个低位使用。

同时，根据操作数据的大小不同，每个指令都有对应的带有数据大小后缀的指令。

在现代系统中，一般不会在同一个寄存器中存储多个数据，虽然同一个指令针对不同的数据大小都不同的版本，但也都是处于性能和优化角度使用的。

举例来说，一个 64 位寄存器中存储 char 类型，如果完整访问 64 位，实际上高位的 54 位都是浪费的，因为根本就不会用到。

#### 数据处理指令

将数据在不同的寄存器之间进行移动并处理，最常用的就是 `mov S, D` 指令。其中，S 是数据源，D 是目标位置。

根据不同的数据大小以及相应的用途，`mov` 指令有如下几个分身：

- `movb`(8位) / `movw`(16位) / `movl`(32位) / `movq`(64位)
- `movzbw` / `movzbl` / `movzbq` / `movzwl` / `movzwq`
- `movsbw` / `movsbl` / `movsbq` / `movswl` / `movswq` / `movslq`
- `movabsq` / `cltq`

关于 mov 指令的几个特点：

1. `mov S, D` 的 S 和 D 不能同为内存地址。对于把一个内存地址的值赋值给另一个内存地址，需要两个 mov 指令才能实现；
2. `movb` 和 `movw` 只会操作目标寄存器的指定位，而不更新高位；
3. `movl` 在写入寄存器时会隐式清零高 32 位，但写入内存时不会影响未覆盖的字节；
4. `movzxx` 和 `movsxx` 用于处理较小值赋值到较大值时的高位扩展问题，z 代表 0 扩展，s 代表符号位扩展。
5. `movzxx` 里没有 `movzlq`，是因为可以直接用 `movl` 的隐式清零高 32 位来实现，不需要额外引入指令；
6. `movabsq` 来处理 64 位的立即数，因为`movq` 被限制最多只能处理 32 位立即数；
7. `ctlq` 用来将 `%eax` 符号扩展到 `%rax`，等价于 `movslq %eax, %rax`；

举例来说：

```assemble
movabsq $0x0011223344556677, %rax   ; %rax = 0x0011223344556677
movb    $0xAA, %dl                  ; %dl = AA

movb    $-1, %al                    ; %rax = 0x00112233445566FF
movw    $-1, %ax                    ; %rax = 0x001122334455FFFF
movl    $-1, %eax                   ; %rax = 0x00000000FFFFFFFF，movl 会隐式清零高 32 位
movq    $-1, %rax                   ; %rax = 0xFFFFFFFFFFFFFFFF

movzbq  $dl, %rax                   ; %rax = 0x00000000000000AA
movsbq  $dl, %rax                   ; %rax = 0xFFFFFFFFFFFFFFAA
```

#### 栈管理指令

栈结构在程序的执行过程中起着至关重要的作用，这里介绍入栈和出栈两个指令。

`%rsp` 是比较特殊的一个寄存器，它用来维护方法或函数的执行状态，主要靠它在固定的调用栈区间内上下移动来维护。

操作系统会为每个进程/线程分配自己的栈空间，让其在自己的栈空间内维护函数调用信息。

一般来说，栈会从从某个高地址开始向下，`%rsp` 就指向该地址，每次入栈新元素向下移动栈指针，出栈元素时向上移动栈指针。如果超出栈指针指向超出系统划定的范围，就是栈溢出。

- `pushq S`

压栈操作包含两个动作：1、将栈指针向下移动 8 个字节；2、将目标元素写入栈指针寄存器。

`pushq %rbp` 等价于下面两条指令：

```assemble
subq $8, %rsp
movq %rbp, (%rsp)
```

注意这里寄存器 `%rbp` 指的就是指令中的 S，这里是将先给新加入的元素开了 8 字节的空间，然后将 `%rbp` 的值复制给了栈指针，完成压栈。

- `popq D`

出栈操作与入栈相反，将当前栈指针指向的内容赋值给 D 寄存器，然后将栈指针回退 8 个字节。

`popq %rax` 等价于：

```assemble
movq (%rsp), %rax 
addq $8, %rsp
```

注意这里只是把栈指针回退了 8 字节，而没有清空上次入栈的时候存储的值。完全依赖栈指针的指向来确定栈顶，之前的数据不会进行处理。

#### 算术运算指令

算术运算指令主要用来处理简单的算术计算，主要包括一元运算、二元运算、移位运算以及 leaq 指令。

以下所有全大写的指令表示的都是具体的分类，实际上每个指令都和 MOV 指令一样，根据不同的数据大小都对应的后缀。

- `INC D`，D++
- `DEC D`，D--
- `NEG D`，D = -D
- `NOT D`，D = ~D

- `ADD S, D`，D = D + S
- `SUB S, D`，D = D - S
- `IMUL S, D`，D = D * S
- `XOR S, D`，D = D ^ S
- `OR S, D`，D = D | S
- `AND S, D`，D = D & S

- `SAL k, D`，D = D << k
- `SHL k, D`，D = D << k
- `SAR k, D`，D = D >> k，算术右移，高位补符号位
- `SHR k, D`，D = D >> k，逻辑右移，高位补 0

- `leaq S, D`，D = &S，leaq 主要用来做地址运算，不会访问该地址的内容

对于位移操作来说，k 的取值可以是立即数或者寄存器 `%cl` 的值。`%cl` 最多存储 8 位，最多能够表示 255，远超有可能操作的 64 位。

在实际应用中，对于特定大小的数据，用该数据的位数对 2 取 log，得到二进制下最多多少位能表示该值，得到真正有效的位移位数，然后从 `%cl` 中取出对应的位数做运算。

或者说，是用 `%cl` 最大能表示的 255，对目标数据的位数取模，就能保证超出当前数据有效位数的值都被截断，最终的结果就是正确的。

比如，假设 `%cl` 的值为 0xFF，则有：

- `salb` 操作 8 位数据，2^3 = 8，也就是 `%cl` 的末尾三位，即 0b111，就是 7；
- `salw` 操作 16 位数据，2^4 = 16，也就是 `%cl` 的末尾四位，即 0b1111，就是 15；
- `sall` 操作 32 位数据，2^5 = 32，也就是 `%cl` 的末尾五位，即 0b11111，就是 31；
- `salq` 操作 64 位数据，2^6 = 64，也就是 `%cl` 的末尾六位，即 0b111111，就是 63；

当然，这里只是说明 `%cl` 中存储的值超出有效位数的情况下，系统会怎么处理。

正常情况下，因为系统设计的问题，如果移位的位数无法有效确认的情况下，只能将该动态值存在 `%cl` 寄存器中，而即便是对于最大的值来说，8 位能表示的数字也足够表示要移动的位数。