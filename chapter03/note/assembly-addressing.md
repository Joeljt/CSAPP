
## x86-64 内存寻址中不同部分的语义

所谓的基址寻址、索引寻址、间接寻址等，实际上只是该公式的特殊情况，它们之间的区别主要是为了方便理解和使用，而不是计算上的本质区别。

参考练习题 [3.1](../practice/3.1.c) 了解更多内容。

| **模式**              | **公式特例**            | **适用场景**                          |
|----------------------|----------------------|----------------------------------|
| **间接寻址** (`(%rbx)`)       | `rb + 0`             | 访问指针指向的地址                     |
| **基址寻址** (`imm(%rbx)`)    | `rb + imm`          | 访问结构体成员、局部变量                 |
| **索引寻址** (`(%rbx, %rsi)`)  | `rb + ri`           | 访问数组中的元素                       |
| **比例索引寻址** (`(%rbx, %rsi, s)`) | `rb + ri × s`       | 访问 `int[]`、`long[]` 等类型的数组 |
| **全模式寻址** (`imm(%rbx, %rsi, s)`) | `imm + rb + ri × s` | 综合各种情况                         |

这里需要注意的是，虽然最终的表现就是指令中的几个值相加得到一个内存中的地址值，但是要注意不同部分的语义。

### 基址（Base Register，rb）

最重要的部分，它提供了一个起始地址，代表当前访问的内存块的基准点。

例如，访问数组时，基址可能是数组的起始地址；访问结构体时，基址可能是结构体的地址。

### 立即数偏移（Immediate Offset，imm）

硬编码的固定偏移量，在编译时就已经确定，不会在运行时变化。

主要用于访问结构体的成员变量，或者全局变量等在固定地址上的数据。

例如：

```assembly
movl 8(%rax), %ebx  ; 访问 %rax 指向的结构体中的某个成员，固定偏移 8
```

这里 8 就是编译时确定的，表示访问结构体中的某个字段。

### 寄存器偏移（Index Register，ri）

运行时动态计算的偏移量，偏移的大小依赖于寄存器的值，因此可以用于访问数组中的任意元素。

例如：

```assembly
movl (%rax, %rbx), %ebx  ; 访问 %rax 基址 + %rbx 计算出的偏移
```

这里 %rbx 可能存的是一个动态计算出来的值，比如数组索引 i，它的值在运行时可能会改变。


### 比例因子（Scale Factor，s）

主要用于数组元素的访问，表示索引的单位，例如数组的元素大小。

出于[内存对齐和硬件设计的原因](#scale-为什么只能是-1248)，这里允许的取值只有 1、2、4、8，对应 1 字节、2 字节、4 字节、8 字节的数据结构。

例如：

```assembly
movl (%rax, %rbx, 4), %ebx  ; 访问 %rax + %rbx * 4 的地址
```

其中：

- %rax 是基地址，指向数组的起始位置。
- %rbx 可能是数组索引（比如 i）。
- 4 是比例因子，表示每个元素占 4 个字节（即 sizeof(int) = 4）。

计算出的地址是 base + index * size，即 %rax + %rbx * 4，这就是数组访问的典型方式。

### 总结

最终所有这些部分都会被相加，得到最终的内存地址，但它们的语义不同：

- 基址：提供访问的基准点，确定要访问的内存块。
- 立即数偏移：固定的偏移量，主要用于访问结构体的成员。
- 寄存器偏移：动态的偏移量，通常是运行时计算出的索引。
- 比例因子：用于数组访问，确定索引步长，单位是字节。

所有这些部分都符合公式：

$$
Address=imm+rb+(ri×s)
$$

每个部分有不同的用途，但最终的计算方式是一致的。

### 其他

#### scale 为什么只能是 1/2/4/8

1. 硬件限制

scale 只能是 1/2/4/8，主要是因为 现代 CPU 通过硬件支持这些倍数的地址计算，这样可以高效地进行 寻址 和 数据加载。
如果允许任意 scale 值，比如 3，那么 CPU 需要额外的乘法运算，而 1/2/4/8 这些值可以通过位移运算高效计算：

- ×1 → 不变
- ×2 → 左移 1 位 (shl x, 1)
- ×4 → 左移 2 位 (shl x, 2)
- ×8 → 左移 3 位 (shl x, 3)

而 ×3、×5 这些非 2 的幂次的数，就需要额外的乘法指令，会影响 CPU 执行效率。

2. 内存对齐

现代 CPU 依赖内存对齐来优化数据访问，而 scale 只能是 1/2/4/8，正好对应常见的数据类型：

- 1 → char
- 2 → short
- 4 → int, float
- 8 → long, double, 指针

这确保了数组元素的地址 天然是对齐的，避免 非对齐访问（unaligned access） 带来的性能下降。

3. 指令集设计

x86-64 设计之初就限定了 scale = 1/2/4/8，因为大多数数据结构都遵循这个规则。如果程序员确实要支持不规则的 scale（比如 3），可以手动计算地址：

```assembly
lea (%rax, %rbx, 3), %rcx  ; 计算 %rax + %rbx * 3
```

但 3 不是 scale 选项之一，所以只能用 lea 指令显式计算，而不能用 mov (%rax, %rbx, 3), %rcx 这样的方式。

综上所述，scale 只能是 1/2/4/8，是 硬件优化、内存对齐和指令集设计 共同决定的结果，主要目的是提高寻址效率，避免非对齐访问，同时保持计算简单高效。