## 整数运算

### 加法溢出

对于计算机来说，不存在符号，只有最基本的二进制加法，所有的符号、负数等都是人为创造的概念。
所以，在进行加法运算时，就正常操作二进制，超过最高位的部分全部丢弃，再根据 32 位二进制数决定最后的结果是什么。

对于无符号数，如果 x + y = s，但是 s < x 或者 s < y 时，我们就可以认定发生了溢出。
同时，由于 x 和 y 最大值为 2^w - 1，所以 x + y 的最大值为 2*(2^w-1) = 2^(w+1) - 2，不会超过 2^w 
但是由于 int 最大可容纳的值为 2^w - 1，所以超出的部分会被截断，即 >= 2^w 的部分都会被截断，最终的结果就是 res % 2^w。
又因为即使是两个最大值相加，额外可以加的最多也就是 2^w - 1，即 2^w-1 + (2^w-1)，所以截断后最终的计算结果实际上就是减去 2^w。

对于有符号数，则分为正溢出和负溢出：
- 两个最大的正数相加，相加的结果会超出 TMax 能表达的值，从而让高位变成 1，最后变成负数；
     - 相当于 x + y - 2^w
- 两个最小的负数相加，相加的结果会超出 TMin 能表达的值，从而让高位变成 0，最后回到正数；
     - 相当于 x + y + 2^w

具体可以参考[相关习题](../practice/2.27.c)。

### 负号的定义

对于任意一个数字 x，都能找到一个数字 y 与 x 相加得到 0，这种情况下我们就给 y 叫做 x 的相反数，表示为 -x。

但是 two's complement 表示下的数字范围是不对称的，负数的最小值 TMin 没有与之对应的正数。

实际上，TMin 的相反数是 TMin 自身。

这是因为在 two's complement 表示下，相反数的定义是到 2^w 的补集，能与 TMin(1...000) 补到 2^w 的只有它自身。

同时，这里有两种方式可以实现 two's complement 的计算：

1. 按位取反后 +1，也就是说 -x === ~x+1;
2. 找到二进制表示中的最后一个 1，然后将该位左侧的所有位取反；

这里尝试实现一下第二种方式。

找到二进制表示的最后一个 1 可以通过 n & (-n) 来实现。

比如 5 & -5 = 0101 &（1010 + 1) = 0101 & 1011 = 0001。

找到以后，让原码和这个结果做位运算，所有在这位之前的都取反（异或 1），之后的保持原样（异或 0）。

所以需要构建一个二进制数，让其前半部分都是 1，后半部分都是 0 即可。

问题就变成了，对于给定的一个二进制数，其中只有一个 1，求出一个数，在 1 在的位置之前都是 1，从 1 开始都是 0。

1. 用该结果 -1，可以将其右侧结果都变成 1，其自身变成 0，之前的位保持 0 不变；
    0001 0000 - 1 得到 0000 1111

2. 再用 ｜运算把最后一个 1 加回来，即 0001 0000 + 0000 1111 得到 0001 1111；
3. 然后对这个结果按位取反，得到 1110 0000；

这样就得到了我们想要的从高位到 1 之前都是 0，从 1 开始到最后都是 1，然后让原码对这个掩码做异或运算，就能让最后一个 1 之前的所有位反转。

```c
int last = n & (-n);
int mask = ~((last - 1) | last)
int res = n ^ mask;
```

### 乘法溢出

乘法溢出与加法一样，只不过不像加法那样有明确的规律。

溢出的本质就是当前类型的位宽无法容纳相应的结果，截断为 32 位后重新确定值。

无论是无符号数还是补码负数，溢出后结果都是 $(x * y) mod 2^w$。

### shift 优化

计算机没有减法，减法会被变种为加上一个负数，然后进行加法运算。

同时，乘法和除法对于机器执行来说远远慢于加法运算，所以编译器会利用移位和加法运算来优化乘除法。

#### 左移等价于乘以 2

通过将常数转换为不同 2 的幂次之间的加减法，编译器能将所有的乘法转换为移位和加法操作。

举例来说，14 === $2^3 + 2^2 + 2^1$ === $2^4 - 2^1$。系统会把 nx14 这个乘法运算优化为 $(n << 4) - (n << 1)$。

练习：

- 6 = 4 + 2 = (x << 2) + (x << 1)
- 31 = 32 - 1 = (x << 5) - x
- -6 = 2 - 8 = (x << 1) - (x << 3)
- 55 = 64 - 8 - 1 = (x << 6) - (x << 3) - x

这里的计算实际上是将常数项转为二进制，然后对二进制做 (a << k) + b 的操作，保证最终结果与原值相同。

这里以 14 为例，14 的二进制表示位 1110：

1. 每一个 1 都是一次 k，所以 k = 3；
2. 末尾的 0 就是 b，所以这里 b = 1；

由此，这里的优化有两种表示方法：

1. $(x << n) + (x << (n - 1)) + (x << (n - 2)) + ... + (x << m)$
2. $(x << (n + 1)) - (x << m)$

#### 右移等价于除以 2

对于无符号和正数，正常除以 2 即可，结果都是正确的。

但是对于负数，需要进行算术右移。右移运算默认向下取整，这对负数来说是错误的，正确的情况应该是向上取整。

比如 30 除以 4 的结果是 7.5，向下取整为 7。对于 -30 除以 4 的结果是 -7.5，向下取整后结果是 -8，但是这里我们期望的也是 -7。

要解决这个问题，需要在执行右移前，先加上一个结果，保证取整后的结果是我们想要的。

我们可以考虑给负数的分子加上一个偏移量，这个偏移量比分母小 1，这样就保证除出来的数字比正常结果大，然后再取整，就正好得到了我们想要的结果。

比如，对于 x = -30，y = 4, 偏移量就是 y - 1 = 4 - 1 = 3。

重新计算就是 (-30 + 3) / 4 = -27 / 4 = -6.75，向下取整后结果是 -7。

对于除以 2 的幂次，偏移量就是 2^k - 1，也就是 (1 << k) - 1。注意，1 << k 等价于 2^k。

综上所述，使用右移运算替换除以 2 的幂次：

$$
(x < 0 ? (x + ((1 << k) - 1)) : x) >> k
$$

