## 信号

### 术语

1. Signals，系统用来通知进程的方式，可以把 signal 看作一条消息或者一个事件；
2. Sending a signal，内核会在两种情况下发送信号：检测到错误、有程序主动调用了 kill 方法；
3. Receiving a signal，程序注册响应函数来接收系统发出的信号，做出对应的处理；
4. Pending signal，发送了但是还未被处理的信号，同一类型的标准信号只有可能存在一个，后来的会被丢弃；
5. Signal handlers，处理信号的自定义函数
    1. 设置这个函数的动作叫 install a signal handler；
    2. 调用这个函数叫 catching the signal；
    3. 执行这个函数的过程叫 handling the signal；

### 发送信号

1. 进程有进程组的概念，每个进程都有一个进程组；
2. 可以调用 kill / alarm 方法来给一个进程或者一个进程组来发送信号；
3. shell 程序的每个命令都对应一个进程；
4. shell 可以有多个后台任务，最多只有一个前台任务；
5. shell 中多个命令用管道符连接在一起的时候，shell 会把多个程序打包到一个进程组里作为前台任务运行；
6. CTRL + C 会发送 SIGINT 信号，默认行为是退出所有前台进程；
7. CTRL + Z 会发送 SIGTSTP 信号，默认行为是挂起所有前台进程； 

### 接收信号

在进程上下文切换时，系统用一个 bit 位来判断当前进程是否有 pending signal（pending & ~blocked）。
这就解释了为什么同类型的信号只能存在一个，因为系统判断的方式是有没有，而不是有几个。

在切换上下文时，如果发现有 pending signal，则会强制目标进程去处理该信号，处理完成后才会执行切换。

不同的信号有不同的默认行为，但是程序可以通过调用 signal 方法指定自己的 handler。
同时，处理信号的 handler 函数仍然可能会响应其他信号的发送，所以调用链条可能会变得很长。

### 信号屏蔽

如前所述，系统会隐式屏蔽掉同类型的 pending signal，程序也可以主动调用 sigprocmask
 屏蔽想屏蔽的信号，原理也是修改对应的 bit 位来实现的。

信号是一种异步机制，在实际系统开发中容易出错，所以 CSAPP 讲了如何屏蔽信号以避免并发问题。

### 信号处理

信号处理函数执行在当前进程的上下文中，但是信号的发送和接收会抢占 CPU 运行，所以也有可能会导致并发问题。
信号是异步的，可能在主程序执行的任意时间点抢占 CPU 资源，打断执行流。

对于这种情况，书中给了几点建议：

1. 尽可能保持函数的简单，减少副作用；
2. 只调用保证异步安全的函数，要么其不会访问公共变量，要么有足够的同步机制保证其不会被中断；
3. 保存并重置 errno，以免过程中不经意间修改该值，导致后续依赖该值的程序出错；
4. 在访问共享变量的时候屏蔽信号的接收，以保证处理该数据的时候独占 CPU 资源，避免数据争抢；
5. 使用 volatile 关键字修饰共享变量，确保其程序每次都从内存中读取该值，而不是使用寄存器缓存；
6. 使用 sig_atomic_t 标记的变量，读写该变量时都是 CPU 级别的原子级操作，无法被打断；

### 非局部跳转

C 语言中的 setjmp 和 longjmp 函数，这两个函数用于异常控制流的处理，它们是 C 语言中实现非局部跳转的工具。

非局部跳转，即从某个地方跳转到另一个地方。这种跳转常常用于异常处理机制，在 C 语言中不直接支持异常处理（如 try 和 catch），所以 setjmp 和 longjmp 提供了类似的功能。

setjmp 用于保存程序的当前执行状态（称为跳转点）。
它会将当前的栈信息，如程序计数器、栈指针等，保存在一个 jmp_buf 变量中，这样在将来的某个时刻就可以通过 longjmp 恢复程序的状态。

longjmp 用于从保存的跳转点恢复程序的执行。
当调用 longjmp 时，程序的控制流会跳回到之前调用过 setjmp 的位置，并从那继续执行。

