## 网络编程

### C/S 模型

互联网存在的前提是 client-server 模型，所有的网络应用都基于该模型生效，即客服端发起请求，服务端响应请求。

这里需要意识到的一个问题是：客户端与服务端仅仅是两个不同的进程而已。

- 客户端进程和服务端进程可以运行在同一台主机上，也可以运行在不同的主机上
- 同一台主机上也可以同时运行多个客户端进程或者服务端进程

### 网络

从硬件层面来看，网络的组成大概分为以下几个部分：

1. I/O 总线上的网卡，让网络上其他主机的数据可以被送到主存以及 CPU 处理；
2. 网络的最小单元是局域网，即 Local Area Network，最有代表性的局域网是以太网（Ethernet）；
    1. LAN 的覆盖范围有限，大概是一栋楼的面积；
    2. Ethernet 的最小单元是一个 Hub，每个 Hub 可以有多个端口，通过网线连接这些端口，再扩展到多个终端，比如一栋楼的多个楼层，或者一层楼的多个房间；
    3. Hub 是一个广播设备，当数据进入 Hub 时，它会复制并发送到所有端口，所有设备都会接收到数据，只有目标设备会处理数据，其他设备会丢弃它（Hub 已经被交换机淘汰，交换机可以学习 MAC 地址，只发给目标设备）；
    4. 在具体的 hub 中，接入局域网后，可以连接自己的路由器，就是我们日常使用的无线局域网，即 WLAN；
        1. 路由器会拆分内网给不同的终端使用，但实际上所有终端的网络出入口都是同一个，即当前的 hub 端口；
3. 多个 Ethernet Hub 可以组成一个 bridged ethernet，覆盖更广的面积，多个 bridge 之间也可以互相连接；
    1. 相较于 hub，网桥之间的传输速度会更快，而且有更优的算法可以记录传输记录，减少广播消耗；
4. 多个网桥之前可以通过路由器 router 进行连接、通信；
5. 由多个路由器串联到一起的一个更大范围的网络，被称为广域网，即 Wide Area Networks；
6. 广域网下不同的设备不互相兼容，所以需要依赖网络传输协议来保证数据的正确传输；
7. 根据网络协议进行数据格式以及地址的转换工作发生在路由器环节，一般被称为路由器跳转；

### IP 协议

这里不讨论 TCP 或者 UDP，只讨论 IP 协议是如何保证 C/S 架构正常运行的，即客户端和服务端是如何定位到彼此的主机位置，从而进行通信的。同时，只讨论 IPv4 的情况。

核心内容主要有：

1. 每个网络接口会被分配一个唯一的 32 位地址值，用来在全球互联网中唯一标记其地址；
    1. 为了人类可读，IPv4 往往被划分为 4 个不同部分，以 . 分隔；
    2. 网络协议的解析统一使用大端序，可以用 htonl/ntohl 方法来处理转换逻辑；
2. DNS 系统用来解析特定的域名为具体的 IP 地址，不用记忆 IP 信息；
    1. 一个域名可能会解析到多个 IP 地址；
    2. 不同的三级域名可能会解析到同一个 IP 地址；
    3. hostname / nslookup 
3. 一个完整的 TCP 连接由：(client_ip, client_port, server_ip, server_port) 四部分构成；
    1. TCP 为全双工通信，即双方都可以向对方进行发送和接受；
    2. 每个服务对应一个进程，每个进程都有自己的 socket 文件，对应主机上不同的端口，用来唯一确定一个进程；
    3. 客户端端口由内核临时分配，服务端端口自己指定或直接使用默认值；
        1. 知名端口：0~1023，由IANA分配，常用于知名服务，需要 root 权限才能改；
        2. 注册端口：1024~49151，IANA 分配了默认值，但是开发者可以改；
        3. 临时端口：49152~65535，临时使用，如客户端连接服务器时动态分配的端口

### sockets

server 端

1. 调用 getaddrinfo 获取可绑定的地址（INADDR_ANY）。
2. 调用 socket() 创建 socket。
3. 调用 setsockopt(SO_REUSEADDR) 允许端口复用（可选）。
4. 调用 bind() 绑定 IP 和端口。
5. 调用 listen() 监听端口。
6. 调用 accept() 阻塞，等待客户端连接。
7. 连接建立后进行 全双工通信。
8. 通信完成后调用 shutdown()，然后 close() 关闭 socket。

client 端

1. 调用 getaddrinfo() 获取 server 的 IP。
2. 调用 socket() 创建 socket。
3. （可选）调用 bind() 绑定特定端口，否则内核会分配随机端口。
4. 调用 connect() 连接 server 端。
5. 连接建立后进行 全双工通信。
6. 通信完成后调用 shutdown()，然后 close() 关闭 socket。

### echo 服务

1. 执行 `make echo_s echo_c` 可以生成客户端以及服务端程序；
2. 在两个进程中分别启动并指定一致的端口，即可运行；

### TINY web server

1. 执行 `make tiny` 可编译 tiny 服务器文件，指定某个端口后即可运行；
2. 在浏览器中输入 `http://localhost:9000` 即可访问 `index.html` 静态页面；
3. 输入 `http://localhost:9000/cgi-bin/adder?15000&213` 即可访问 adder 加法器程序，在运行时执行并返回给前端；
    - 核心原理是：子进程 + execve + dup2 I/O 重定向