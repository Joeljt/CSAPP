## 数据在内存中的存储

主要是 C 中的数据结构表示，核心还是：

- 指针本质上就是内存地址，& 生成指针，* 引用具体地址指向的内容
- C 里实际上没有数组，都是指针，指针在数组的应用场景下可以进行算术运算，从而实现数组的索引

### 数组的表示

数组本质上就是一段连续的内存空间，其中每个成员的 size 都是固定的。

malloc 返回基地址，也就是 arr[0] 的地址值，根据索引获取值本质上只是在基地址的基础上进行 `i` 个值的偏移。

注意这里的偏移需要考虑每个成员的 size，而不是 1 字节偏移：

$$
\&E[i] = M[x_E + bytesize \times i]
$$

其中，x_E 指的是基地址，也就是数组第一个元素的地址。

对应的汇编代码是：

```assembly
movl (%rdx,%rcx,bytesize), %eax
```

在机器的表示中，数组只是一段连续的地址空间，而指针指向这一段地址空间的起始位置，仅此而已。

所以无论是一维数组还是二维矩阵，都是一个连续的地址空间，所谓的 `a[1][3]` 这种表示也只是上层的表示，本质上是偏移量计算的问题。

以一个声明为 `int arr[5][3]` 的二维数组为例，表示的是一个有 5 个元素的数组，其中每个元素是一个有 3 个元素的数组。

每个元素的大小为 3 * 4 = 12 字节，5 个元素即 5 * 12 = 60 字节。所以需要给 arr 开辟一个 60 字节大小的内存空间。

```
基地址 -->   [xx][xx][xx][xx][xx][xx][xx][xx][xx][xx][xx][xx][xx][xx][xx] 
            |- arr[0] -||- arr[1] -||- arr[2] -||- arr[3] -||- arr[4] -|
            ^           ^           ^           ^           ^
            +0          +12         +24         +36         +48
```

更详细的展开：
```
内存地址：    +0   +4   +8   +12  +16  +20  +24  +28  +32  ...
            [   arr[0]    ][   arr[1]    ][   arr[2]    ]...
            [0,0][0,1][0,2][1,0][1,1][1,2][2,0][2,1][2,2]...
```

访问示例：
- arr[1][2] = *(arr + (1*3 + 2)*4)  基地址 + (1*3 + 2)*4 = 基地址 + 20
- arr[2][1] = *(arr + (2*3 + 1)*4)  基地址 + (2*3 + 1)*4 = 基地址 + 28

可以看到，二维数组在内存中实际上就是一维数组，只不过每个元素是一个一维数组。

在汇编层，编译器会直接把所有的数组索引访问，无论是一维还是二维，都转换为单纯的基地址偏移。

如果是动态数组，还需要用寄存器去存取遍历过程中的 i 变量，对于固定大小的数组，编译会直接把对应的偏移量计算出来，使用立即数来进行偏移访问，效率更高。

### 指针

指针的本质就是地址值的操作，每个指针都有关联的类型，强制类型转换的时候改变的只是上层高级语言的解释，机器层面的 bit pattern 是不会有变化的。

`NULL(0)` 是特殊值，表示当前指针不指向任何地址空间。

可以对指针进行简单的算术运算，作用场景实际上就是数组的索引取值。

对于 `int *p`，`p + 3` 的动作实际是 `p + 4 * 3`。其中 4 表示 int 类型的 4 字节。

用函数指针可以指代一个函数：`int (*f) (int * a)` 表示一个函数指针，接收一个 int 类型的指针作为参数，返回一个 int。

注意中间的括号不可省略，否则函数指针的声明 `*` 会和返回值类型一起解析为 `int*`，是不合法的函数指针声明。

### struct & union

C 可以用 struct 和 union 对数据进行封装，用来对待解决的问题建模。

struct 和 union 的区别在于：

- struct 中的每个成员是按顺序排列的，每个成员都有自己对应的内存空间
- union 会按照声明的成员中最大的那个进行空间的分配，各个成员共享同一块内存。
    - 一般来说，union 的适用场景是多个成员之间是互斥的，所以可以用尽量少的内存完成一样的工作，但是可读性比较差

以结构体为例，系统就是分配一段连续的内存空间，在分配的过程中会保证内存对齐，返回的地址值就是结构体的第一个成员，其他成员的访问都是基于基地址进行的偏移。
