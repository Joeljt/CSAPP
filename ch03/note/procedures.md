## 函数执行流程与调用栈

在 x86-64 架构下，除了 16 个通用寄存器之外，系统还维护了用于处理其他任务的寄存器。其中两个重要的寄存器是：

- **`%rip`（指令指针寄存器，Instruction Pointer）**
  - 作为 x86-64 体系中的 **程序计数器（Program Counter）**，存储当前执行指令的地址，用于控制程序流程。

- **`%rsp`（栈指针寄存器，Stack Pointer）**
  - 指向当前 **栈顶**，函数调用和返回时会修改。

### 栈帧（Stack Frame）

```
高地址
│
│  ...  （上层调用者的栈帧）
│  return address     （call 指令自动压入，属于上层调用者的栈帧）
│  saved registers    （push 指令保存的寄存器）
│  local variables    （sub rsp, size 预留的空间）
│  arguments area     （第 7 个及之后的参数）
└──> 低地址 (%rsp)
```

#### **栈帧的关键点**
- 不是所有的函数调用都会创建栈帧（如 `leaf function` 可能直接用寄存器）。
- 栈帧从 **高地址到低地址** 依次存储：
  - **返回地址**
  - **保存的寄存器**
  - **局部变量**
  - **第 7 个及之后的参数**

- **`%rbp`（Base Pointer，基址指针）**
  - 传统上用于存储当前栈帧的基址，访问局部变量时提供一个稳定的地址参考。
  - 现代编译器可能省略 `rbp`，直接使用 `rsp` 进行局部变量访问。

#### **函数进入（Prologue）**
```assembly
push rbp
mov rbp, rsp
sub rsp, size  ; 预留局部变量空间
```

#### **函数退出（Epilogue）**
```assembly
mov rsp, rbp
pop rbp
ret
```

### 函数调用流程

1. **调用 `call` 指令**，执行一个新函数。
2. **`call` 指令的作用**：
   - **压入 return address**（即下一条指令地址）。
   - **跳转到目标函数**（更新 `%rip`）。
3. **函数执行**：
   - **若有参数**，从寄存器或栈帧中读取参数。
   - 可能 **创建栈帧** 并分配局部变量。
4. **执行 `ret` 指令**，返回调用点：
   - **弹出 return address**（等效于 `pop rip`）。
   - **继续执行调用者函数的后续代码**。

### 参数传递规则（System V AMD64 ABI）

#### **整数参数**
- **前 6 个整数参数** 存放在：
  - `rdi, rsi, rdx, rcx, r8, r9`
- **第 7 个及之后的参数** 存入 **调用者栈帧**（高地址方向）。

#### **浮点参数**
- **前 8 个浮点数参数** 存放在：
  - `xmm0 - xmm7`
- **第 9 个及之后的参数** 存入 **调用者栈帧**。

#### **Windows x64 ABI（与 System V 不同）**
- **整数参数** 存放在 `rcx, rdx, r8, r9`
- **浮点参数** 存放在 `xmm0 - xmm3`
- 额外参数存入调用者栈帧。

### 局部变量管理

- **局部变量存储在 local storage 区域**。
- **开辟/回收空间的方式**：
  - 通过移动 `%rsp` 指针完成，无需手动清空内存。
  ```assembly
  sub rsp, 32  ; 预留 32 字节
  add rsp, 32  ; 释放 32 字节
  ```

### 寄存器的保存规则

由于寄存器是所有程序共享的，调用函数时必须保证 **数据的保存和还原**。寄存器分为 **Caller-Saved** 和 **Callee-Saved**：

#### **Caller-Saved（调用者负责保存）**
- **调用前需自己备份，否则调用后可能丢失**。
- **常见 Caller-Saved 寄存器**：
  - `rax, rcx, rdx, rsi, rdi, r8 - r11`

#### **Callee-Saved（被调用者负责保存）**
- **进入函数前必须保存，返回时恢复**。
- **常见 Callee-Saved 寄存器**：
  - `rbx, rbp, r12 - r15`
- **保存/恢复方式**：
  ```assembly
  push rbx
  push r12
  push r13
  ...
  pop r13
  pop r12
  pop rbx
  ```

### 栈的对齐要求

**System V AMD64 ABI 规定：**
- **调用前 `%rsp` 必须 16 字节对齐**，否则会影响 SIMD 指令访问。
- **但 `call` 指令会 `push rip`，导致 `rsp` 变为 16n**，因此：
  - 调用前 `sub rsp, 8` 保持 16 字节对齐。

### **补充：leaf function（叶子函数）**
- **叶子函数**：不调用其他函数的函数，可能不会创建完整栈帧。
- **优化策略**：直接使用寄存器存储局部变量，避免 `push rbp` 和 `mov rbp, rsp`。

### **总结**
1. **`%rip` 指向当前指令，`%rsp` 指向栈顶**。
2. **`call` 指令会压入 return address，`ret` 通过弹出地址返回**。
3. **前 6 个整数参数存寄存器，第 7 个及之后的参数存栈**。
4. **局部变量存栈，`sub rsp, size` 预留，`add rsp, size` 释放**。
5. **Caller-Saved 寄存器调用者负责保存，Callee-Saved 寄存器被调用者负责保存**。
6. **栈必须 16 字节对齐，必要时 `sub rsp, 8` 以保持对齐**。
