## 缓存的组成结构和映射

### 组成结构

缓存的基本工作原理是：

1. 当 CPU 需要访问某个内存中的数据时，它会先检查缓存中是否有该数据。
2. 如果有，CPU 直接从缓存中读取数据，而不需要访问内存。
3. 如果没有，CPU 会从内存中读取数据，并将其存储在缓存中，以便下次访问时可以更快地读取。

很明显，整个过程类似从哈希表中取值，其中 key 为要访问的地址值，value 是该地址对应的数据。但缓存的读写操作并不是基于地址的，而是基于地址的映射。

根据局部性原理，CPU 可能会重复访问（temporal）相邻的地址空间（spatial），所以缓存体系被设计为缓存目标地址所在的一个数据块，而不是一个个独立的地址数据。

这个数据块被称为缓存行，是缓存体系中的最小单位，一般是 64 字节。

一个缓存块，或缓存行，包含多个元素，每个元素中存储着一个真实的二进制数据，该数据可以通过地址值的偏移量作为索引进行获取。

多个缓存行可以构成一个缓存组，多个缓存组组合到一起就构成了缓存结构。

### 缓存索引和访问

根据前面的内容我们了解到，缓存的工作方式类似于哈希表，而哈希表的工作方式是通过哈希函数将 key 映射到 value，从而实现快速查找。

在缓存中，索引 key 值是对地址值进行拆分组合得到的，整个过程类似于浮点数的 IEEE 754 拆分。

假设我们的缓存有 8 个缓存组，每个缓存组包括 4 个缓存行，每个缓存行大小为 64 字节，则对于任意一个 64 位地址值，我们可以将其拆分为三个部分：

- 低 6 位：用来确定该值存在缓存块中的哪个位置，block offset，2^6 = 64 字节；
- 中间 3 位：用来确定该值所在的缓存组编号，set index，2^3 = 8 个缓存组（**具体值由硬件设计决定**）；
- 高 55 位：用来确定该值位于哪个缓存行或者缓存块，tag；

拆分规则如下：

```txt
[ Tag (55 位) ]  [ Set Index (3 位) ]  [ Block Offset (6 位) ]
```

需要明确的一点是，缓存中存储的一个个的数据块，也就是 64 字节的数据，表示一个连续地址空间中存储的二进制数据，而不是地址本身。

当 CPU 执行指令时需要某个地址的数据时，会将该地址按照上面的拆分规则进行拆分，然后通过这三个部分来从缓存中取出该值，这里取到的值就是二进制数据，只不过是从缓存中取到的，不是访问内存得到的。

除了按照上面的规则构建缓存结构以外，每个缓存行还有一个 `valid` 位，用来标记该缓存行是否有效。

这个 `valid` 位属于缓存行的元数据，不占用地址值空间。

可以想象 Cache 的数据结构声明如下：

```c
struct CacheLine {
    bool valid;         // 有效位 (Valid Bit)
    unsigned long tag;  // 标记位 (Tag)
    uint8_t data[64];   // 数据块 (64 字节)
};

struct CacheSet {
    CacheLine lines[4]; // 每个 Set 里有 4 个 Cache Line
};
```

缓存访问步骤：

- 计算 Set Index，找到具体的缓存组（Set）。
- 在这个 Set 内部遍历 所有 CacheLine，看有没有 Tag 匹配且 Valid Bit = 1 的缓存行。
    - 命中（Hit）：使用 Offset 从 data[64] 里取数据
    - 未命中（Miss）：从主存加载数据到缓存，可能需要替换（如 LRU 规则）
    - 替换（Replace）：替换掉当前的 CacheLine，然后将新数据写入 CacheLine

> 可以将缓存结构类比为一本笔记本，它由多页（Set）组成：
> 
> - Set Index 是页码，决定数据在哪一页（Set）
> - Tag 是行号，确定该数据存在哪一行（Cache Line）。
> - Offset 是字的位置，在缓存行（64 字节块）里找到具体的字节。
> 
> 这样，对于一个地址：
>
> - Set Index 选定具体的 页（Set）。
> - Tag 确定在这页里的哪一行（Cache Line）。
> - Offset 选择 行中的某个字节。
> 
> 最终，Set Index + Tag + Offset 唯一确定了缓存中的数据位置

### 缓存映射

根据缓存组和缓存行的不同，缓存可以按照不同的方式组织：

- 直接映射（Direct Mapped）：每个内存块只能映射到一个缓存行（组关联度为 1）。
- n-全相联映射（Set Associative）：每个内存块可以映射到多个缓存行中的某一个行（组关联度为 n），这意味着每个缓存组内有 n 行缓存。
- 全关联缓存（Full Associative）：每个内存块可以映射到任意一个缓存行（组关联度是缓存行的总数）。

选择不同的映射方式主要是性能、硬件实现复杂程度、成本等因素共同的权衡。

假设两个地址，set index 的值相同，tag bits 不同，则它们会被映射到同一个缓存组中，但是不在同一个缓存行。

对于这种情况来说，

1. 直接映射每个 set 只有一个缓存行，所以每次都会 conflict miss，然后不同替换更新缓存；
2. 组关联映射由于每组有多个缓存行，所以有一定的冲突容错能力，可以减少冲突 miss；
3. 全关联映射与组关联类似，但是由于缓存行不分组，导致查找的时候需要全部遍历匹配，复杂度为 O(n)，所以性能不如组关联。

总体上来看，通过区分不同的缓存结构，计算机系统可以在性能、成本和复杂性之间做出优化选择，以适应各种不同的应用场景和系统需求。

- **性能 vs. 成本**：全关联缓存提供最高的命中率，但硬件实现最复杂且成本最高。直接映射缓存实现简单，查找速度快，但命中率较低。组关联缓存则是性能与成本之间的折中。
- **不同应用场景**：不同的系统需求不同的缓存结构。例如，在 嵌入式系统 中，可能更倾向于使用 直接映射缓存 以降低硬件复杂性和功耗；而在 高性能计算 或 数据密集型应用 中，可能会选择 全关联缓存 或 高路组关联缓存 来最大化性能。
- **数据访问模式**：不同的访问模式会对缓存结构产生不同的影响。如果内存访问具有 局部性（例如，访问模式是线性的），则 直接映射缓存 的性能就可能接近组关联缓存和全关联缓存。相反，如果内存访问模式是随机的，组关联缓存和全关联缓存的优势会更加明显。

### 缓存大小与缓存行

缓存行的数量主要与整个缓存的大小和每个缓存行的大小有关，而与缓存组的数量无关。

具体来说，**缓存行的数量**可以通过以下公式计算：

$$
\text{缓存行数} = \frac{\text{缓存总大小}}{\text{每个缓存行大小}}
$$

这个计算不涉及缓存的组数，而是简单地反映了缓存的总容量和每行缓存的大小。

### 解释：
1. **缓存总大小**：缓存的整体容量（比如 64KB，128KB 等）。
2. **缓存行大小**：每个缓存行占用的字节数（比如 64 字节，128 字节等）。

因此，**缓存行的数量**是由整个缓存的总容量和每个缓存行的大小共同决定的。

假设我们有一个 64KB 的缓存，缓存行大小为 64 字节，且是 4-way 组关联缓存。我们可以通过以下步骤来计算每个缓存组内的缓存行数：

1.  计算缓存总行数：
    
    $$
    \text{总缓存行数} = \frac{\text{缓存总大小}}{\text{缓存行大小}} = \frac{64 \, \text{KB}}{64 \, \text{字节}} = 1024 \, \text{行}
    $$

2.  计算每个缓存组内的缓存行数： 由于是 4-way 组关联缓存，每个组内有 4 行缓存。
    
3.  计算缓存组的数量：
    
    $$
    \text{缓存组数} = \frac{\text{总缓存行数}}{\text{组关联度}} = \frac{1024 \, \text{行}}{4 \, \text{行/组}} = 256 \, \text{组}
    $$

因此，在这个例子中，**每个缓存组有 4 行缓存**，总共有 256 个缓存组。

### 缓存组：
缓存组的数量与 **组关联度**（例如，2-way、4-way、8-way 等）有关。对于组关联缓存，缓存被分为若干组，每组内有多个缓存行。组数是由 **缓存行的数量** 和 **组关联度** 决定的，公式为：

$$
\text{缓存组数} = \frac{\text{缓存行数}}{\text{组关联度}}
$$

所以，**缓存组的数量**与缓存行的数量是有关系的，但缓存行的数量本身与缓存组数无关。
